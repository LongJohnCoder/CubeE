;
;	File:		ADBPrimitives.a
;
;	Contains:	low-level hardware-dependent ADB and DebugUtil routines
;
;	Written by:	Steve Christensen 
;
;	Copyright:	© 1991-1993 by Apple Computer, Inc.  All rights reserved.
;
;   This file is used in these builds: ROM
;
;	Change History (most recent first):
;
;	   <SM9>	 11/9/93	KW		added some eieioSTP macros.  Only expands for CygnusX1 ROM
;	   <SM8>	  8/4/93	JDR		private sound defines were moved to SoundPrivate.a
;	   <SM7>	 6/14/93	kc		Roll in Ludwig.
;	   <LW2>	 1/21/93	KW		CudaDebugEnter should not send PDMSuspend command...should just
;									fall through to EgretDebugEnter.  CudaDebugExit should send
;									PDMDebugContinue instead of PDMContinue.  Bug fix #1049224
;	   <SM6>	11/23/92	SWC		Put the build conditionals back in. Added a table for Cuda and
;									fixed the Cuda routines so they don't require any Universal
;									checks (the whole point of using primitives).
;	   <SM5>	 8/26/92	kc		Roll in Horror changes.
;		<H4>	 8/25/92	BG		Changed VIAStartReq at @waitforinput so that the code waits for
;									at least 8.8µs before switching the direction of the shift
;									register (output to input) to guarantee that we don't outrun the
;									ADB micro's ability to respond.  Removed <H3>.
;		<H3>	 7/10/92	BG		Added a temporary KLUDGE to ViaDebugPoll to allow typing in
;									MacsBug/etc. to function 'normally' again.  See the comments for
;									more details.
;		<H2>	  5/3/92	BG		Removed references to hasOrwell2, since it is now superfluous to
;									hasOrwell.
;	   <SM4>	07-14-92	jmp		Added a changed to make typing MacsBug work a little better on
;									Quadra 700s until GR finds a better way to do this.
;	   <SM3>	 7/10/92	mal		Changed include from ApplDeskBusPriv.a to AppleDeskBusPriv.a.
;	   <SM2>	 5/28/92	KW		(GS,P3) Added suspend/continue PDM to the Debug util code.
;		 <1>	 5/17/92	kc		first checked in
;	   <SM0>	  5/2/92	kc		Roll in Horror. Comments follow:
;		<H1>	  4/3/92	SWC		Adding this file into the build.


			PRINT	OFF
			LOAD	'StandardEqu.d'
			INCLUDE	'HardwarePrivateEqu.a'
			INCLUDE	'UniversalEqu.a'
		IF PwrMgrADB THEN
			INCLUDE	'PowerPrivEqu.a'
		ENDIF
		IF hasEgret THEN
			INCLUDE	'EgretEqu.a'
		ENDIF
		IF IopADB THEN
			INCLUDE	'IopEqu.a'
		ENDIF
			INCLUDE	'AppleDeskBusPriv.a'
			INCLUDE	'IOPrimitiveEqu.a'
			PRINT	ON
			PRINT	NOMDIR
			MACHINE	MC68020

NoIntMask	EQU		$0700					; all ints disabled on all machines



ADBPrimitives PROC	EXPORT

			IMPORT	ImplicitRequestDone, ExplicitRequestDone

			WITH	ADBVars,ADBMsg


;————————————————————————————————————————————————————————————————————————————————————————
;
;	ADB primitives vector table
;
;	Tables pointed to by the universal ProductInfo record (ADBDebugUtilPtr) for low-level
;	hardware-dependent ADB routines.  There should be a table for each supported
;	ProductInfo.


		IF ViaADB THEN
			EXPORT	ViaADBTable
			DC.W	0									; flags
			DC.W	(VIATableEnd-ViaADBTable)/4			; number of entries
ViaADBTable
			DC.L	VIAInitADB-ViaADBTable				; ADB initialization
			DC.L	0									; not used
			DC.L	0									; not used
			DC.L	0									; not used
			DC.L	VIADebugPoll-ViaADBTable			; DebugUtil ADB polling
			DC.L	0									; not used
VIATableEnd
		ENDIF


		IF PwrMgrADB THEN
			EXPORT	PMgrADBTable
			DC.W	0									; flags
			DC.W	(PMGRTableEnd-PMgrADBTable)/4		; number of entries
PMgrADBTable
			DC.L	PMgrInitADB-PMgrADBTable			; ADB initialization
			DC.L	PMgrEnableKbdNMI-PMgrADBTable		; not used
			DC.L	0									; not used
			DC.L	0									; not used
			DC.L	PMgrDebugPoll-PMgrADBTable			; DebugUtil ADB polling
			DC.L	0									; not used
PMGRTableEnd

			EXPORT	PMgrADBTable2
			DC.W	0									; flags
			DC.W	(PMGRTableEnd2-PMgrADBTable2)/4		; number of entries
PMgrADBTable2
			DC.L	PMgrInitADB-PMgrADBTable2			; ADB initialization
			DC.L	PMgrEnableKbdNMI-PMgrADBTable2		; not used
			DC.L	0									; not used
			DC.L	0									; not used
			DC.L	PMgrDebugPoll2-PMgrADBTable2		; DebugUtil ADB polling
			DC.L	0									; not used
PMGRTableEnd2
		ENDIF


		IF hasEgret THEN
			EXPORT	EgretADBTable
			DC.W	0									; flags
			DC.W	(EgretTableEnd-EgretADBTable)/4		; number of entries
EgretADBTable
			DC.L	EgretInitADB-EgretADBTable			; ADB initialization
			DC.L	0									; not used
			DC.L	EgretDebugEnter-EgretADBTable		; DebugUtil enter
			DC.L	EgretDebugExit-EgretADBTable		; DebugUtil exit
			DC.L	EgretDebugPoll-EgretADBTable		; DebugUtil ADB polling
			DC.L	0									; not used
EgretTableEnd

			EXPORT	CudaADBTable
			DC.W	0									; flags
			DC.W	(CudaTableEnd-CudaADBTable)/4		; number of entries
CudaADBTable
			DC.L	EgretInitADB-CudaADBTable			; ADB initialization
			DC.L	0									; not used
			DC.L	CudaDebugEnter-CudaADBTable			; DebugUtil enter
			DC.L	CudaDebugExit-CudaADBTable			; DebugUtil exit
			DC.L	EgretDebugPoll-CudaADBTable			; DebugUtil ADB polling
			DC.L	0									; not used
CudaTableEnd
		ENDIF


			EXPORT	AlphaADBTable
			DC.W	0								; flags
			DC.W	(AlphaTableEnd-AlphaADBTable)/4	; number of entries
AlphaADBTable
			DC.L	AlphaInitADB-AlphaADBTable		; ADB initialization
			DC.L	0								; not used
			DC.L	AlphaDebugEnter-AlphaADBTable	; DebugUtil enter
			DC.L	AlphaDebugExit-AlphaADBTable	; DebugUtil exit
			DC.L	AlphaDebugPoll-AlphaADBTable	; DebugUtil ADB polling
			DC.L	0								; not used
AlphaTableEnd


			EXPORT	DummyADBTable
			DC.W	0								; flags
			DC.W	(DummyTableEnd-DummyADBTable)/4	; number of entries
DummyADBTable
			DC.L	DummyInitADB-DummyADBTable		; ADB initialization
			DC.L	0								; not used
			DC.L	0								; DebugUtil enter
			DC.L	0								; DebugUtil exit
			DC.L	0								; DebugUtil ADB polling
			DC.L	0								; not used
DummyTableEnd


			EXPORT	BetaADBTable
			DC.W	0								; flags
			DC.W	(BetaTableEnd-BetaADBTable)/4	; number of entries
BetaADBTable
			DC.L	BetaInitADB-BetaADBTable		; ADB initialization
			DC.L	0								; not used
			DC.L	BetaDebugEnter-BetaADBTable		; DebugUtil enter
			DC.L	BetaDebugExit-BetaADBTable		; DebugUtil exit
			DC.L	BetaDebugPoll-BetaADBTable		; DebugUtil ADB polling
			DC.L	0								; not used
BetaTableEnd


		IF ViaADB THEN
;••••••••••••••••••••••••••••••••••••••••• VIA ••••••••••••••••••••••••••••••••••••••••••

			IMPORT	RunADBRequest

;________________________________________________________________________________________
;
; Routine:	VIAInitADB
;
; Inputs:	A3	-	pointer to ADBBase
;
; Outputs:	
;
; Trashes:	A0
;
; Function:	initializes the ADB Manager for VIA-based ADB
;________________________________________________________________________________________

VIAInitADB	LEA		FDBShiftInt,A0			; get the address of the interrupt handler
			MOVE.L	A0,Lvl1DT+(4*ifSR)		;  and install it as the SR interrupt receiver
			LEA		VIAStartReq,A0			; setup the procedure to start an ADB request
			MOVE.L	A0,StartReqProc(A3)
			MOVEA.L	VIA,A0					; point to the VIA1 registers
			ORI		#NoIntMask,SR			; mask out interrupts
		eieioSTP
			MOVE.B	#(1<<ifIRQ)|\			; enable the shift register interrupt
					 (1<<ifSR),vIER(A0)
		eieioSTP
			RTS


;________________________________________________________________________________________
;
; Routine:	VIAStartReq
;
; Inputs:	A2	-	pointer to transmit data buffer
;			A3	-	pointer to ADBBase
;			D2	-	number of bytes of transmit data
;			D3	-	command byte (bits 0-7) + implicit flag (bit 31)
;
; Outputs:	A1	-	pointer to base of VIA1
;			A3	-	pointer to ADBBase
;
; Trashes:	D0,D1,D3
;
; Function:	starts an ADB request using the VIA interface to the ADB transceiver processor
;________________________________________________________________________________________

VIAStartReq	MOVEA.L	VIA,A1					; point to VIA1
			BSET	#fDBBusy,FDBAuFlag(A3)	; remember that we are busy
			BNE.S	@AlreadyBusy			; -> already busy, so do nothing and return

			TST.L	D3						; is this an implicit request?
			BPL.S	@Explicit				; -> nope

;	send an implicit command (auto / SRQ polling), no data needs to be sent

@Implicit	MOVE.B	PollAddr(A3),D3			; get the auto/SRQ polling address
			LSL.B	#4,D3
			ORI.B	#talkCmd+0,D3			;  and make it a Talk R0 command
			BSR		@SendCmd				; send out the command byte
			BEQ.S	@AutoReply				; -> see if prior auto poll data returned instead

			MOVE.B	fDBCmd(A3),pollCmd(A3)	; remember the command byte
			BSR.S	@StartAutoPoll			; start auto polling
			BTST	#fDBQEmpty,FDBFlag(A3)	; see if anything queued
			BNE.S	@Idle					; -> no, just wait for auto poll data

;	We have just changed from state 0 to state 3.  If a command is in the queue, we will
;	want to change back to state 0, and send a new command.  We have to give the xcvr
;	processor time to recognize the state change into state 3 before we change back to
;	state 0, otherwise it will be out of sync.

			MOVE.W	TimeViaDB,D0		; get 1ms VIA loop time constant
		;	LSR.W	#4,D0				; 1ms/16 = 62.5µs
		;•••• STP ••• eric -- let's double it??
			lsr.w	#2,d0				; 1ms/16 = 62.5µs
@Delay	
		eieioSTP
			BTST	#0,vBufB(A1)		; timing based on BTST loop, we don't care
		eieioSTP
			DBRA	D0,@Delay			; wait at least 50µs for state change to occur
			BSR.S	@Idle				; mark us idle
			BRA.L	RunADBRequest		; go run the next request in the queue

@Idle		BCLR	#fDBBusy,FDBAuFlag(A3)	; allow explicit cmds to interrupt auto polling
@AlreadyBusy
			RTS							; if not, just let auto polling continue

@StartAutoPoll
			MOVEQ	#(1<<vFDesk1)|\
					(1<<vFDesk2),D1		; change from state 0 to state 3
			BSR		@waitForInput		; start auto polling, wait for a reply
			ORI.B	#(1<<fDBAPoll)|\	; indicate that auto poll data returned
					(1<<fDBBusy),FDBAuFlag(A3)	; auto poll found something, we're busy again
			MOVEQ	#(1<<vFDesk2),D1	; change from state 3 to state 1
			BRA.S	@getReply			; join common code to get reply

@explicit	MOVEQ	#maskADBCmd,D0		; setup to extract command
			AND.B	D3,D0				; clear addr and reg
			SUBQ.B	#listenCmd,D0		; check for listen command
			BEQ		@listen				; explicit listen is special case

;	send an explicit command (other than listen), no data needs to be sent

			BSR.S	@sendCmd			; send out the command byte
			BNE.S	@explicitReply		; see if auto poll data returned instead
@autoReply	BSET	#fDBAPoll,FDBAuFlag(A3)	; indicate that auto poll data returned
			MOVE.B	pollCmd(A3),fDBCmd(A3)	; poll command is command that is completing
@explicitReply

			MOVEQ	#(1<<vFDesk1),D1	; change from state 0 to state 1
@getReply	BSR.S	@waitForInput		; wait for the first byte
			BNE.S	@noTimeout			; see if timeout occured
			BSET	#fDBNoReply,FDBAuFlag(A3)	; indicate that no reply data was returned
@noTimeout	CLR.B	fDBCnt(A3)			; indicate buffer empty

			BSR.W	@getNextByte		; wait for the second byte
			BNE.S	@noSRQ				; see if SRQ occured
			BSET	#fDBSRQ,FDBAuFlag(A3)	; indicate that no service request was returned
@noSRQ

@fetchLoop	BSR.W	@getNextByte		; wait for another byte
			BEQ.S	@fetchDone			; exit if end of data reached
			CMPI.B	#8,fDBCnt(A3)		; see if end of buffer reached
			BLO.S	@fetchLoop			; keep fetching until end of data
@fetchDone	BTST	#fDBNoReply,FDBAuFlag(A3)	; see if buffer data is valid
			SEQ		D0					; $FF if data is valid, $00 if no reply
			AND.B	D0,fDBCnt(A3)		; set count to zero if timeout
			BRA		VIAReqDone


@sendCmd	ANDI.B	#$FF-(\
					(1<<fDBAPoll)|\		; clear auto poll reply flag
					(1<<fDBSRQ)|\		; clear SRQ active in reply flag
					(1<<fDBNoReply)),\	; clear reply timeout flag
					FDBAuFlag(A3)		; clear the flags
			MOVE.W	SR,D0				; save int mask
			ORI		#NoIntMask,SR		; disable ALL interrupts

			MOVEQ	#(1<<vFDesk2)+\
					(1<<vFDesk1),D1		; mask the current state
		eieioSTP
			AND.B	vBufB(A1),D1
			CMPI.B	#(1<<vFDesk2)+\
					(1<<vFDesk1),D1		; are we in state 3?
			BNE.S	@SendCont			; no, procede as usual
		eieioSTP
			BTST	#vFDBInt,vBufB(a1)	; yes, test the FDBInt~ status
		eieioSTP
			BEQ.S	@SendExit			; asserted, xcvr already clocking autopoll data
										; exit (wait for autopoll to complete)

@SendCont
		eieioSTP
			ORI.B	#$1C,vACR(a1)		; set SR to shift-out with ext clk
		eieioSTP
			MOVE.B	D3,vSR(a1) 			; load shift reg with cmd, start shifting
		eieioSTP
			MOVE.B	D3,fDBCmd(A3)		; save the command
		eieioSTP
			ANDI.B	#-1-(1<<vFDesk2)-\
					(1<<vFDesk1),vBufB(A1)	; force state bits to zero
		eieioSTP
@SendExit	MOVE.L	(SP)+,ShiftIntResume(A3); save resume address
			MOVE	D0,SR				; restore interrupt mask
			RTS							; return to callers caller, wait for interrupt


@waitForInput
;	Shouldn't do the change to shift-in mode til rising edge of ADB clock, which could		<H4> thru next <H4>
;	be a max. of 8.8µs after getting the shift register interrupt from sending out the
;	command byte.  These TSTs aren't to actually test a condition - they are to wait
;	the appropriate amount of time before changing mode.  We have already done 2 accesses
;	to the VIA, so we have 2.4µs of time already accounted for.
		eieioSTP
			tst.b	vBufB(A1)			; wait for ADB xcvr to have a rising edge (~8.8µs)
		eieioSTP
			tst.b	vBufB(A1)			; (each of these should be ~1.2µs)
		eieioSTP
			tst.b	vBufB(A1)
		eieioSTP
			tst.b	vBufB(A1)
		eieioSTP
			tst.b	vBufB(A1)
		eieioSTP
			tst.b	vBufB(A1)
		eieioSTP
			tst.b	vBufB(A1)			;													<H4>
		eieioSTP
			BCLR	#4,vACR(A1)			; change to shift-in mode
		eieioSTP
			TST.B	vSR(A1) 			; empty shift reg to start shifting
		eieioSTP
			EOR.B	D1,vBufB(A1)		; change the state
		eieioSTP
			MOVE.L	(SP)+,ShiftIntResume(A3); save resume address
			RTS							; return to callers caller, wait for interrupt


@getNextByte
			LEA		fDBCnt(A3),A0		; point to the length byte of the buffer
			MOVEQ	#1,D0				; zero extend the index
			ADD.B	(A0),D0				; get, and increment the index
			MOVE.B	D0,(A0)				; update the index
		eieioSTP
			MOVE.B	vSR(a1),(A0,D0.W)	; save the new byte in the buffer
		eieioSTP
			EORI.B	#(1<<vFDesk1)|\
					(1<<vFDesk2),vBufB(A1)	; alternate between state 1 and state 2
		eieioSTP
			MOVE.L	(SP)+,ShiftIntResume(A3); save resume address
		eieioSTP
			RTS							; return to callers caller, wait for interrupt

;	send an explicit Listen command, send data buffer.
;
; Inputs:	D2	-	length of transmit buffer data
;			D3	-	command byte / implicit flag (bit 31)
;			A2	-	pointer to buffer containing transmit data
;			A3	-	pointer to ADBBase

@listen		SUBQ.B	#2,D2				; check for min length of 2
			BHS.S	@minOK				; if >= 2, use it
			MOVEQ	#0,D2				; otherwise use 0, which will become 2
@minOK		SUBQ.B	#8-2,D2				; check for max length of 8
			BLS.S	@maxOK				; if <= 8, use it
			MOVEQ	#0,D2				; otherwise use 0, which will become 8
@maxOK		ADDQ.B	#8,D2				; restore count
			MOVE.B	D2,fDBCnt(A3)		; update buffer length
			MOVE.L	A2,ListenBuffPtr(A3); save buffer starting address

			BSR.S	@sendCmd			; send out the command byte
			BEQ		@autoReply			; see if auto poll data returned instead

			BSR.S	@sendFirstByte		; send the first byte
			BNE.S	@noListenTimeout	; see if timeout occured
			BSET	#fDBNoReply,FDBAuFlag(A3)	; indicate that no reply data was returned
@noListenTimeout
			BSR.S	@sendNextByte		; send the second byte
			BNE.S	@sendLoop			; if no SRQ, send the data
			BSET	#fDBSRQ,FDBAuFlag(A3)	; remember that a service request was returned

@sendLoop	TST.B	fDBCnt(A3)			; see if end of buffer reached
			BEQ.S	VIAReqDone			; leave when count is zero, no reply data
			BSR.S	@sendNextByte		; send another byte
			BRA.S	@sendLoop			; loop until count exhausted



@sendFirstByte
			MOVEQ	#(1<<vFDesk1),D1	; change from state 0 to state 1
			BRA.S	@sendByte			; join common code

@sendNextByte
			MOVEQ	#(1<<vFDesk1)|\
					(1<<vFDesk2),D1		; alternate between state 1 and state 2
@sendByte	MOVEA.L	ListenBuffPtr(A3),A0; get the buffer pointer
		eieioSTP
			MOVE.B	(A0)+,vSR(A1)		; send the byte
		eieioSTP
			MOVE.L	A0,ListenBuffPtr(A3); update the buffer pointer
			SUBQ.B	#1,fDBCnt(A3)		; decrement the send count
		eieioSTP
			EOR.B	D1,vBufB(A1)		; change the state
		eieioSTP
			MOVE.L	(SP)+,ShiftIntResume(A3); save resume address
		eieioSTP
			RTS							; return to callers caller, wait for interrupt


;________________________________________________________________________________________
;
; Routine:	FDBShiftInt
;
; Inputs:	A1	-	pointer to base of VIA1
;
; Outputs:	A1	-	pointer to base of VIA1
;			A3	-	pointer to ADBBase
;			CCR	-	BEQ/BNE based on state of vFDBInt bit in VIA1's buffer B
;
; Trashes:	A0
;
; Function:	handles the shift register interrupt and resumes asynchronous processing
;________________________________________________________________________________________

FDBShiftInt	MOVEA.L	ADBBase,A3				; point to ADB globals
			MOVEA.L	ShiftIntResume(A3),A0	;  and get the address to resume at
		eieioSTP
			BTST	#vFDBInt,vBufB(A1)		; test the FDBInt~ status
		eieioSTP
			JMP		(A0)					; resume async processing


;________________________________________________________________________________________
;
; Routine:	VIAReqDone
;
; Inputs:	A3	-	pointer to ADBBase
;
; Outputs:	A2	-	pointer to receive data buffer
;			A3	-	pointer to ADBBase
;			D2	-	number of bytes of receive data
;			D3	-	command byte (bits 0-7) + SRQ flag (bit 31)
;
; Trashes:	A0,D0,D1
;
; Function:	completion routine for servicing replies from the ADB transceiver
;________________________________________________________________________________________

VIAReqDone	MOVE.B	FDBAuFlag(A3),D0		; get the flags
			MOVE.B	fDBCmd(A3),D1			;  and the command
			MOVEQ	#(1<<fDBSRQ),D3			; mask to test for SRQ pending
			AND.B	D0,D3
			NEG.L	D3						; set bit 31 if SRQ pending
			MOVE.B	D1,D3					; insert the command byte

			LSR.B	#4,D1					; isolate the device address
			TST.L	D3						; was there an SRQ?
			BPL.S	@NoSRQ					; -> no, don't advance the poll address

			MOVE.W	DevMap(A3),D2			; get the list of possible address to search
			BSET	D1,D2					; if no other bits are set, come back to this one

@SRQloop	ADDQ.B	#1,D1					; try the next address
			ANDI.B	#$0F,D1					; wrapping around if needed (clear bit 7, autopoll addr change)
			BTST	D1,D2					; is there a device with that address?
			BEQ.S	@SRQloop				; -> no, try the next address

@NoSRQ		MOVE.B	D1,PollAddr(A3)			; remember where to auto/SRQ poll next

			LEA		fDBCnt(A3),A0			; point to the length byte of the buffer
			MOVEQ	#0,D2					; zero extend the length
			MOVE.B	(A0)+,D2				; get length of receive data
			MOVEA.L	A0,A2					; point to the data buffer

			CLR.B	FDBAuFlag(A3)			; clear the flags, especially fDBBusy
			BTST	#fDBAPoll,D0			; see what kind of request completed
			BNE.L	ImplicitRequestDone		; auto poll data returned, call handler
			BRA.L	ExplicitRequestDone		; if explicit, call the completion routine


		ENDIF								; {ViaADB}


		IF ViaADB | hasEgret THEN
;________________________________________________________________________________________
;
; Routine:	VIADebugPoll,EgretDebugPoll
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	A0,A1,A3,...
;
; Function:	DebugUtil code to check if ADB data is available, for implementations that
;			use the VIA1 shift register interrupt
;________________________________________________________________________________________

VIADebugPoll
EgretDebugPoll
			MOVEA.L	VIA,A1					; point to the VIA
			BTST	#ifSR,vIFR(A1)			; is the shift register full?
		eieioSTP
			BEQ.S	@PollDone				; -> no, just return
			MOVE.L	Lvl1DT+(4*ifSR),-(SP)	; get the handler address
@PollDone	RTS								;  and call the interrupt handler

		ENDIF


		IF PwrMgrADB THEN
;•••••••••••••••••••••••••••••••••••• Power Manager •••••••••••••••••••••••••••••••••••••

			WITH	pmCommandRec

;________________________________________________________________________________________
;
; Routine:	PMgrInitADB
;
; Inputs:	A3	-	pointer to ADBBase
;
; Outputs:	none
;
; Trashes:	A0
;
; Function:	initializes the ADB Manager for Power Manager based ADB
;________________________________________________________________________________________

PMgrInitADB	LEA		PMgrStartReq,A0			; setup the procedure to start an ADB request
			MOVE.L	A0,StartReqProc(A3)
			LEA		PMgrReqDone,A0			; get the address of the interrupt handler
			MOVE.L	A0,Lvl1DT+(4*ifSR)		;  and install it as the SR interrupt receiver
			RTS


;________________________________________________________________________________________
;
; Routine:	PMgrEnableKbdNMI
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	none
;
; Function:	Enables the NMI "programmer's key" on Power Manager based systems so we can
;			break into a debugger if one is installed.  The reason this is an option is
;			that if the key is turned on without a debugger, the unaware user can die a
;			gory "deep shit" death if they hit the key accidentally.
;________________________________________________________________________________________

PMgrEnableKbdNMI
			MOVEM.L	D0/A0,-(SP)
			MOVE.B	#1,-(SP)				; buffer contains enable flag
			MOVE.L	SP,-(SP)				;  pmRBuffer
			MOVE.L	(SP),-(SP)				;  pmSBuffer
			MOVE.W	#1,-(SP)				;  pmLength
			MOVE.W	#$24,-(SP)				;  pmCommand = enable/disable keyboard NMI
			MOVEA.L	SP,A0					; point to the parameter block
			_PMgrOp							; send the command
			LEA		pmRBuffer+4+2(SP),SP	; clean up the stack
			MOVEM.L	(SP)+,D0/A0
			RTS


;________________________________________________________________________________________
;
; Routine:	PMgrStartReq
;
; Inputs:	A2	-	pointer to transmit data buffer
;			A3	-	pointer to ADBBase
;			D2	-	number of bytes of transmit data
;			D3	-	command byte (bits 0-7) + implicit flag (bit 31)
;
; Outputs:	A1	-	pointer to base of VIA1
;			A3	-	pointer to ADBBase
;
; Trashes:	A0,D0,D3
;
; Function:	sends an ADB request to the Power Manager and asynchronously waits for a reply
;________________________________________________________________________________________

PMgrStartReq
			MOVEA.L	VIA,A1					; point to the base of VIA1
			MOVE.B	#(0<<ifIRQ)|\
					 (1<<ifCB1),vIER(A1)	;  and disable the interrupt since it's set

		eieioSTP
			LEA		-12(SP),SP				; allocate a buffer on the stack
			MOVEA.L	SP,A0					;  and point to it
			MOVE.L	A0,-(SP)				;  pmRBuffer
			MOVE.L	A0,-(SP)				;  pmSBuffer
			MOVEQ	#3,D0					; transmit length is size of buffer + 3
			ADD.B	D2,D0
			MOVE.W	D0,-(SP)				;  pmLength
			MOVE.W	#PMgrADB,-(SP)			;  pmCommand

			MOVEQ	#(0<<pMgrAutoPoll)|\
					 (0<<pMgrPollEnable),D0 ; explicit, poll disabled
			TST.L	D3						; is this an explicit request?
			BMI.S	@Implicit				; -> no, go set exerything up

			BSET	#fDBExpActive,fDBAuFlag(A3)	; remember that an explicit command has been sent
			BNE.S	@DontCall				; -> it's already been sent, so just exit
			BRA.S	@Explicit

@Implicit	MOVE.B	PollAddr(a3),d3			; get the auto/srq polling address
			BMI.S	@DontCall				; -> already autopolling, so don't call to restart
			TestFor	PMgrNewIntf				; does the PMGR do auto-polling?
			BEQ.S	@oldPMGR				; -> no, let the CPU manage it
			MOVE.B	#(1<<pMgrSetPoll)|\
					 (1<<pMgrAutoPoll)|\
					 (1<<pMgrPollEnable),D0 ; set autopoll, poll enabled if implicit
			SWAP	D0
			MOVE.W	DevMap(A3),D0			; pass the Polling Enable bit map
			MOVE.L	D0,(A0)					; fill in our transmit buffer
			MOVE.W	#4,pmLength(SP)			; reset count to 4 bytes for this command
			BRA.S	@SendCmd				;  and send it

@oldPMGR	MOVEQ	#1<<pMgrAutoPoll,D0		; set auto poll if implicit
			LSL.B	#4,D3					; position the address
			ORI.B	#talkCmd+0,D3			; make it a Talk R0 command

@Explicit	MOVE.B	D3,(A0)+				;  command
			MOVE.B	D0,(A0)+				;  flags
			MOVE.B	D2,(A0)+				;  send data count
			BRA.S	@CopyStart				; start the copy

@CopyLoop	MOVE.B	(A2)+,(A0)+				; copy into the message buffer one byte at a time
@CopyStart	DBRA	D2,@CopyLoop

@SendCmd	MOVEA.L	SP,A0					; point to the parameter block
			_PmgrOp							; send the request to the PMGR
@DontCall	LEA		pmRBuffer+4+12(SP),SP	; clean up the stack

			MOVE.B	#(1<<ifIRQ)|\
					 (1<<ifCB1),vIER(A1)	; re-enable PMGR interrupts
		eieioSTP
			RTS


;________________________________________________________________________________________
;
; Routine:	PMgrReqDone
;
; Inputs:	A0	-	???????????????????????????????
;			A3	-	pointer to ADBBase
;
; Outputs:	A2	-	pointer to receive data buffer
;			A3	-	pointer to ADBBase
;			D2	-	number of bytes of receive data
;			D3	-	command byte (bits 0-7) + SRQ flag (bit 31)
;
; Trashes:	A0,D0,D1
;
; Function:	completion routine for servicing messages received from the PMGR
;________________________________________________________________________________________

PMgrReqDone	MOVEA.L	ADBBase,A3				; point to ADB globals

			MOVE.B	(A0)+,D1				; get the command that completed
			MOVE.B	(A0)+,D0				;  and the flags byte

			MOVEQ	#(1<<pMgrSRQ),D3		; mask to test for SRQ pending
			AND.B	D0,D3
			NEG.L	D3						; set bit 31 if SRQ pending
			MOVE.B	D1,D3					; insert the command byte

;	Keep the ADB Parser program happy by updating the following variables.
;	They are not used by this implementation, but we fill them in with
;	approximate values to make the tool happy.

			MOVE.B	D3,fDBCmd(A3)			; save the last ADB command
			MOVE.B	D3,pollCmd(A3)			; assume that it was a poll command

			LSR.B	#4,D1					; isolate the device address
			BSET	#7,D1					; indicate no change in autopoll address needed

			TestFor	PMgrNewIntf				; does the PMGR do auto-polling?
			BEQ.S	@oldPMGR				; -> no, let the CPU manage it
			BTST	#pMgrPollEnable,D0		; is polling enabled?
			BNE.S	@noSRQ					; -> yes, skip
			BCLR	#7,D1					; indicate a new autopoll address is needed
			BRA.S	@noSRQ

@oldPMGR	TST.L	D3						; was there an SRQ?
			BPL.S	@noSRQ					; -> no, don't advance the poll address

			MOVE.W	DevMap(A3),D2			; get the list of possible address to search
			BSET	D1,D2					; if no other bits are set, come back to this one

@SRQloop	ADDQ.B	#1,D1					; try the next address
			ANDI.B	#$0F,D1					; wrapping around if needed (clear bit 7, autopoll addr change)
			BTST	D1,D2					; is there a device with that address?
			BEQ.S	@SRQloop				; -> no, try the next address

@noSRQ		MOVE.B	D1,PollAddr(A3)			; remember where to auto/SRQ poll next

			MOVEQ	#0,D2					; get the length of received data
			MOVE.B	(A0)+,D2
			MOVEA.L	A0,A2					; point to the data buffer

			BTST	#pMgrAutoPoll,D0		; see what kind of request completed
			BNE.S	@Implicit				; -> polling command, so figure out what to do

			TestFor	PMgrNewIntf				; does the PMGR do auto-polling?
			BNE.S	@Explicit				; -> yes
			BCLR	#7,PollAddr(A3)			; indicate that PollAddr address should be used
@Explicit	BCLR	#fDBExpActive,fDBAuFlag(A3)	; remember that it has completed
			BRA.L	ExplicitRequestDone		; call the completion routine

@Implicit	BRA.L	ImplicitRequestDone		; auto poll data was returned, so call the handler


;________________________________________________________________________________________
;
; Routine:	PMgrDebugPoll
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	A1
;
; Function:	DebugUtil code to check if ADB data is available
;________________________________________________________________________________________

PMgrDebugPoll
			MOVEA.L	VIA,A1					; point to the VIA
			BTST	#ifCB1,vIFR(A1)			; does the PMgr have some data?
		eieioSTP
			BEQ.S	@PollDone				; -> no, just return
			MOVE.L	Lvl1DT+(4*ifCB1),-(SP)	; get the handler address
@PollDone	RTS								;  and call the interrupt handler


;________________________________________________________________________________________
;
; Routine:	PMgrDebugPoll2
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	A1
;
; Function:	DebugUtil code to check if ADB data is available
;________________________________________________________________________________________

PMgrDebugPoll2
			MOVE.L	VIA,D3					; point to the VIA
			SUB.L	#$16000,D3				; mysterious data check, cf above
			MOVE.L	D3,A1
			MOVE.B	$59(A1),D3
			AND.B	#2,D3
		eieioSTP
			BNZ.S	@PollDone				; -> no data, just return
			MOVE.L	Lvl1DT+(4*ifCB1),-(SP)	; get the handler address
@PollDone	RTS								;  and call the interrupt handler


		ENDIF								; {PwrMgrADB}



		IF hasEgret THEN
;•••••••••••••••••••••••••••••••••••••••• Egret •••••••••••••••••••••••••••••••••••••••••

			WITH	EgretPB

jEgretDispatch EQU	OSTable+($92*4)			; OS trap table entry for _EgretDispatch


;________________________________________________________________________________________
;
; Routine:	EgretInitADB
;
; Inputs:	A3	-	pointer to ADBBase
;
; Outputs:	
;
; Trashes:	A0,A1
;
; Function:	initializes the ADB Manager for Power Manager based ADB
;________________________________________________________________________________________

EgretInitADB
			LEA		EgretStartReq,A0		; setup the procedure to start an ADB request
			MOVE.L	A0,StartReqProc(A3)
			MOVE.W	#(specialPkt<<8)+\		; pbCmdType = special packet
					 (aPoll<<0),\			; pbCmd = install/remove autopoll handler
					 ImplicitEPB.pbCmdType(A3)	; init the param block
			RTS


;________________________________________________________________________________________
;
; Routine:	EgretStartReq
;
; Inputs:	A2	-	pointer to transmit data buffer
;			A3	-	pointer to ADBBase
;			D2	-	number of bytes of transmit data
;			D3	-	command byte (bits 0-7) + implicit flag (bit 31)
;
; Outputs:	A1	-	pointer to base of VIA1
;			A3	-	pointer to ADBBase
;
; Trashes:	A0,A1,A2,D0,D1,D2,D3
;
; Function:	sends an ADB request to Egret and asynchronously waits for a reply
;________________________________________________________________________________________

EgretStartReq
			TST.L	D3						; is this an implicit request?
			BPL.S	@Explicit				; -> no

@Implicit	BTST	#fDBInit,fDBFlag(A3)	; is initialization happening?
			BNE.S	@impDone				; -> yes, implicit commands are ignored
			BSET	#fDBImpInited,fDBAuFlag(A3)	; has implicit command initialization occured?
			BNE.S	@impDone				; -> yes, we're done

			LEA		ImplicitEPB(A3),A0		; point to the autopoll parameter block
			LEA		@ImplicitCompleted,A1	; handler address
			MOVE.L	A1,pbCompletion(A0)		; install the handler
			BSR		@SendToEgret			; install the autopoll handler

			MOVE.L	#(pseudoPkt<<24)\		;  pcCmdType = pseudo packet
					+(wrDevList<<16),D0		;  pbCmd = write device list
			MOVE.W	DevMap(A3),D0			; pbParam = device map
			BSR.S	@syncReq				; send command to specify auto polling addresses

			MOVE.L	#(pseudoPkt<<24)\		;  pcCmdType = pseudo packet
					+(aPoll<<16)\			;  pbCmd = autoPoll
					+($FF<<8),D0			;  pbParam = $FF (only high byte is used)
											; send command to start auto polling

@syncReq	LEA		-EgretPBSize(SP),SP		; put a parameter block on the stack
			MOVEA.L	SP,A0					;  and point to it
			MOVE.L	D0,pbCmdType(A0)		; init pcCmdType, pbCmd, and high word of pbParam
			CLR.L	pbCompletion(A0)		; no completion routine, sync call
			BSR.S	@SendToEgret			; send the request off to the ADB micro
			LEA		EgretPBSize(SP),SP		; deallocate the param block
@ignoreExplicit
@impDone	RTS								; auto-polling/srq data will arrive unsolicited from now on


@ImplicitCompleted
			MOVEQ	#(1<<EgSRQ),D3			; mask to test for SRQ pending
			AND.B	(A1)+,D3
			NEG.L	D3						; set bit 31 if SRQ pending
			MOVE.B	(A1)+,D3				; get the ADB command byte
			MOVEQ	#0,D2					; zero extend the length
			MOVE.W	D0,D2
			MOVEA.L	A1,A2					; get the buffer pointer
			BSR		@FillInVars				; setup A3 and ADB globals for ADB Parser
			BRA.L	ImplicitRequestDone		; return control to the ADB Manager


@Explicit	BSET	#fDBExpRunning,fDBAuFlag(A3); explicit command starting, so exclude new ones
			BNE.S	@IgnoreExplicit				; -> it's already in progress, so don't run it twice
			MOVE.B	D3,ExplicitEPB.pbCmd(A3)	; setup the ADB command,
			MOVE.W	D2,ExplicitEPB.pbByteCnt(A3);  byte count,
			MOVE.L	A2,ExplicitEPB.pbBufPtr(A3)	;  buffer pointer

			BSET	#fDBExpInited,fDBAuFlag(A3)	; see if explicit command initialization has occured
			BNE.S	@expInited					; if already inited, no need to change anything

			LEA		@ExplicitCompleted,A0			; explicit request completion routine address
			MOVE.L	A0,ExplicitEPB.pbCompletion(A3)	; setup buffer pointer

			LEA		ImplicitEPB(A3),A0		; point to the autopoll parameter block
			CLR.L	pbCompletion(A0)		; no completion routine
			BSR.S	@SendToEgret			; remove the auto poll handler

			MOVE.L	#(pseudoPkt<<24)\		;  pcCmdType = pseudo packet
					+(aPoll<<16)\			;  pbCmd = autoPoll
					+($00<<8),D0			;  pbParam = $00 (only high byte is used)
			BSR.S	@syncReq				; send command to stop auto polling

@expInited	LEA		ExplicitEPB(A3),A0		; point to the param block
@SendToEgret
			MOVEQ	#0,D1					; zero the trapword flag bits (in case they ever get used)
			MOVEA.L	jEgretDispatch,A2		; get the OSTrap table entry
			JMP		(A2)					; _EgretDispatch, issue the request (asynchronously), return


@ExplicitCompleted							; A0 points to the EgretPB
			MOVEQ	#(1<<EgSRQ),D3			; mask to test for SRQ pending
			AND.B	pbFlags(A0),D3
			NEG.L	D3						; set bit 31 if SRQ pending
			MOVE.B	pbCmd(A0),D3			; get the ADB command byte
			MOVEQ	#0,D2					; zero extend the length
			MOVE.W	pbByteCnt(A0),D2
			MOVEA.L	pbBufPtr(A0),A2			; get the buffer pointer
			BSR.S	@FillInVars				; setup A3 and ADB globals for ADB Parser
			BCLR	#fDBExpRunning,fDBAuFlag(A3)	; explicit command completed, allow new ones

;	Egret must check the ADB Device address against the Device Bitmap to see if the device exists.
;	If it does not, force Egret to poll the mouse as the MRU device and keyboard as the LRU device.
;	This fixes an Egret bug.

			MOVE.L	#EgretFWMask,D1			; don't do this hack for a Cuda!
			AND.L	UnivROMFlags,D1
			CMP.L	#Cuda,D1
			BEQ.S	@ExpDone

			MOVE.W	Devmap(A3),D1			; get the ADB device Bitmap
			btst.l	D0,D1					; does this device exist?
			BNE.S	@ExpDone				; -> yes, done

			LEA		-EgretPBSize(SP),SP		; put a parameter block on the stack
			MOVEA.L	SP,A0					;  and point to it
			CLR.L	pbCompletion(A0)		; no completion routine
			MOVE.W	#(pseudoPkt<<8)+\
					(Wr6805addr<<0),pbCmdType(A0)	; packet type & command
			MOVE.W	#(MouseAddr<<12)+\		; put mouse address into bits 12-15 (MRU)
					(KbdAddr<<4),-(SP)		;  and keyboard address into bits 4-7 (LRU)
			MOVE.L	SP,pbBufPtr(A0)			; buffer pointer
			MOVE.W	#MRUAddr,pbParam(A0)	; Egret address to write
			MOVE.W	#2,pbByteCnt(A0)		; 2 bytes to write
			_EgretDispatch					; issue the call
			LEA		EgretPbSize+2(SP),SP	; clean up the stack

@ExpDone	BRA.L	ExplicitRequestDone		; return control to the ADB Manager


;	Keep the ADB Parser program happy by updating the following variables.
;	They are not used by this implementation, but we fill them in with
;	approximate values to make the tool happy.

@FillInVars	MOVEA.L	ADBBase,A3				; point to ADB globals in low memory
			MOVE.B	D3,fDBCmd(A3)			; last ADB command
			MOVE.B	D3,pollCmd(A3)			; assume that it was a poll command
			MOVE.B	D3,D0					; copy the command
			LSR.B	#4,D0					; get the address
			MOVE.B	D0,pollAddr(A3)			; assume that it was a poll address
			RTS


;________________________________________________________________________________________
;
; Routine:	CudaDebugEnter
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	D0, D1, A0
;
; Function:	DebugUtil code to be executed when entering a debugger: turns off one-second
;			interrupts
;________________________________________________________________________________________

CudaDebugEnter
			; fall thru into EgretDebugEnter


;________________________________________________________________________________________
;
; Routine:	EgretDebugEnter
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	D0, D1, A0
;
; Function:	DebugUtil code to be executed when entering a debugger: turns off one-second
;			interrupts
;________________________________________________________________________________________

EgretDebugEnter
			RTS


;________________________________________________________________________________________
;
; Routine:	CudaDebugExit
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	D0, D1, A0
;
; Function:	DebugUtil code to be executed when exiting a debugger: turns on one-second
;			interrupts
;________________________________________________________________________________________

CudaDebugExit
			MOVEQ	#PDMDebugCont,D1		; continue PDM							<LW2>
			BSR.S	EgretDebugPDM			;										<P3>
			; fall thru into EgretDebugExit


;________________________________________________________________________________________
;
; Routine:	EgretDebugExit
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	D0, D1, A0
;
; Function:	DebugUtil code to be executed when exiting a debugger: turns on one-second
;			interrupts
;________________________________________________________________________________________

EgretDebugExit
			RTS


;________________________________________________________________________________________
;
; Routine:	EgretDebugPDM
;
; Inputs:	D1 - contains the PDM Selector	
;			Disable = 0, Enable = 1, Suspend = 2, Continue = 3
;
; Outputs:	none
;
; Trashes:	D0, D1, A0
;
; Function:	DebugUtil code to be executed when entering/exiting a debugger: 
;			if Egret chip with Cuda firmware, suspend/continue PDM
;________________________________________________________________________________________

EgretDebugPDM
			moveq	#EgretPBSize/2-1,d0		;											<P3>
@ClearPB	clr.w	-(sp)					; zero all fields in the parameter block	<P3>
			dbra	d0,@ClearPB				; (forces mode 0 and no completion vector)	<P3>
			movea.l	sp,a0					; point to the parameter block				<P3>
			move.w	#(PseudoPkt << 8) \	
					+ EnDisPDM,pbCmdType(a0); Enable PowerDown Messages					<P3>
			move.b	d1,pbParam(a0) 			; PDM Selector								<P3>
			_EgretDispatch					;											<P3>
			LEA		EgretPbSize(SP),SP		; clean up the stack						<P3>
			rts


		ENDIF								; {hasEgret}



		IF 1 THEN
;•••••••••••••••••••••••••••••••••••• Alpha •••••••••••••••••••••••••••••••••••••


AlphaNotSureWhatThisIs
                move.b  ([ExpandMem],$2A0),d3
                cmpi.b  #$FF,d3
                beq.s   @return
                movea.l #$12345678,a0
                cmpa.l  a0,a1
                beq.s   @normv
                movea.l a1,a0
                _RmvTime
@normv
                movem.l d4-d7/a4-a6,-(sp)
                movea.l ADBBase,a3
                moveq   #2,d2
                moveq   #0,d3
                move.b  ([ExpandMem],$2A0),d3
                ror.w   #8,d3
                move.b  #$FF,d3
                move.w  d3,-(sp)
                movea.l sp,a2
                moveq   #0,d3
                move.b  ([ExpandMem],$2A1),d3
                ori.l   #$80000000,d3
                bsr.l   IMPLICITREQUESTDONE
                lea     2(sp),sp
                move.b  #$FF,([ExpandMem],$2A0)
                movem.l (sp)+,d4-d7/a4-a6
@return
                rts



AlphaInitADB

                lea     AlphaStartReq,a0
                move.l  a0,StartReqProc(a3)
                movea.l ([$68FFEFD0],$30),a0 ; HWInfo.ADB_Base
                move.l  a0,DeviceBase(a3)
                tst.l   a0
                beq.w   @return
                move.b  #$C,$100(a0)
                eieioSTP


                move.l  a1,-(sp)

                lea     sub_72C6,a0
                suba.l  a1,a1
                moveq   #0,d0
                move.w  ([$68FFEFD0],$84),d0 ; HWInfo.ADBIntVect

                movem.l d1/a2,-(sp)
                movea.l ([ExpandMem],$210),a2
                lea     8(a2),a2
                moveq   #$40,d1
@loc_70BE
                cmp.w   $18(a2),d0
                beq.s   @loc_70CE
                OPT NONE
                adda.w	#32,a2
                OPT ALL
                dbra    d1,@loc_70BE
                bra.s   @loc_70D4
@loc_70CE
                move.l  a0,(a2)
                move.l  a1,4(a2)
@loc_70D4
                movem.l (sp)+,d1/a2

                movem.l d0-d2/a0,-(sp)
                movea.l ([$68FFEFD0],$18),a0
                tst.l   a0
                bne.s   @loc_7120
                movea.l ([$68FFEFF0],$100),a0
                move.l  #$80000000,d1
                cmpi.l  #$1F,d0
                bgt.s   @loc_710E
                ror.l   d0,d1
                or.l    d1,$14(a0)
                eieioSTP
                bra.w   @loc_7136
@loc_710E
                subi.l  #$20,d0
                ror.l   d0,d1
                or.l    d1,4(a0)
                eieioSTP
                bra.w   @loc_7136
@loc_7120
                adda.l  #$10000,a0
                lsl.l   #5,d0
                move.l  (a0,d0.w),d1
                bclr    #7,d1
                move.l  d1,(a0,d0.w)
                eieioSTP
@loc_7136
                movem.l (sp)+,d0-d2/a0

                movea.l (sp)+,a1

                movea.l DeviceBase(a3),a0
                clr.b   $E0(a0)
                eieioSTP
                bset    #0,$A0(a0)
                eieioSTP
@return         rts


;________________________________________________________________________________________
;
; Routine	AlphaStartReq
;
; Inputs	A2	-	pointer to transmit data buffer
;			A3	-	pointer to ADBBase
;			D2	-	number of bytes of transmit data
;			D3	-	command byte (bits 0-7) + implicit flag (bit 31)
;
; Outputs	A1	-	pointer to base of VIA1
;			A3	-	pointer to ADBBase
;
; Function	starts an ADB request using the VIA interface to the ADB transceiver processor
;________________________________________________________________________________________


AlphaStartReq   movea.l DeviceBase(a3),a1
                tst.l   a1
                bnz.s   @have_adb_hardware
                moveq   #0,d2
                movea.l d2,a2
                bset    #7,fDBAuFlag(a3)
                tst.l   d3
                bmi.s   @earlyreturn ; implicit request with no hardware
                bra.l   EXPLICITREQUESTDONE

@have_adb_hardware
                tst.l   d3
                bpl.s   loc_71B8
                btst    #2,fDBAuFlag(a3)
                bne.s   @earlyreturn
                bclr    #6,fDBAuFlag(a3)
                beq.s   @loc_7194
                move.b  PollAddr(a3),d3
                lsl.b   #4,d3
                ori.b   #$C,d3
                moveq   #0,d2
                bset    #1,fDBAuFlag(a3)
                bra.s   loc_71B8
@loc_7194
                moveq   #0,d0
                move.w  DevMap(a3),d0
                move.b  d0,$100(a1)
                eieioSTP
                lsr.w   #8,d0
                move.b  d0,$F0(a1)
                eieioSTP
                bset    #7,fDBAuFlag(a3)
                bset    #0,$E0(a1)
                eieioSTP

@earlyreturn    rts

loc_71B8

                btst    #2,fDBAuFlag(a3)
                bne.s   loc_7204
                lea     $1A1(a3),a0
                andi.w  #$FF,d2
                addq.b  #1,d2
                move.b  d2,(a0)+
                move.b  d3,(a0)+
                subq.b  #2,d2
                bmi.s   loc_71D8

loc_71D2
                move.b  (a2)+,(a0)+
                dbra    d2,loc_71D2

loc_71D8
                bset    #0,$D0(a1)
                eieioSTP
                bclr    #0,$E0(a1)
                eieioSTP
                bclr    #7,fDBAuFlag(a3)

loc_71EE
                btst    #1,(a1)
                bne.s   loc_71FC
                btst    #0,(a1)
                beq.s   loc_71EE
                rts

loc_71FC
                bset    #2,fDBAuFlag(a3)
                bsr.s   sub_7242
loc_7204

; Spin for 2ms
                moveq   #2,d1
@two_msec       move.w  TimeDBRA,d0
@one_msec       btst    #0,(a1)
                bne.s   locret_7240
                dbra    d0,@one_msec
                dbra    d1,@two_msec


                moveq   #0,d2
                move.l  d2,d3
                move.b  $1A2(a3),d3
                movea.l d2,a2
                bclr    #2,fDBAuFlag(a3)
                btst    #1,fDBAuFlag(a3)
                beq.l   EXPLICITREQUESTDONE
                bclr    #1,fDBAuFlag(a3)
                bra.l   IMPLICITREQUESTDONE

locret_7240
                rts



sub_7242

; FUNCTION CHUNK AT ROM0002B47E SIZE 00000036 BYTES

                clr.b   $C0(a1)
                eieioSTP
                move.b  d3,d0
                andi.b  #$F,d0
                bne.s   loc_7282
                bclr    #0,$D0(a1)
                eieioSTP
                bclr    #1,(a1)
                eieioSTP
                bset    #3,$D0(a1)
                eieioSTP

loc_7266
                btst    #3,$D0(a1)
                bne.s   loc_7266
                lea     4(sp),sp

loc_7272
                moveq   #0,d2
                movea.l d2,a2
                bclr    #2,fDBAuFlag(a3)
                bra.l   EXPLICITREQUESTDONE

loc_7282
                lea     $1A1(a3),a2
                moveq   #0,d0
                move.b  (a2)+,d0
                move.b  d0,$B0(a1)
                eieioSTP
                subq.b  #1,d0
                lea     (a1),a0

loc_7294
                lea     $10(a0),a0
                move.b  (a2)+,(a0)
                eieioSTP
                dbra    d0,loc_7294
                move.b  d3,d0
                andi.b  #$C,d0
                cmpi.b  #$C,d0
                bne.s   loc_72B0
                moveq   #6,d0
                bra.s   loc_72B8

loc_72B0
                moveq   #2,d0
                lea     loc_7272,a0
                move.l  a0,(sp)

loc_72B8
                move.b  d0,$D0(a1)
                eieioSTP
                bclr    #1,(a1)
                eieioSTP
                rts
; End of function sub_7242




sub_72C6


; FUNCTION CHUNK AT ROM0002B47E SIZE 00000036 BYTES

                movea.l ADBBase,a3
                movea.l DeviceBase(a3),a1
                tst.l   a1
                beq.s   locret_72DC
                btst    #0,(a1)
                bne.s   loc_72DE
                clr.b   (a1)
                eieioSTP

locret_72DC
                rts

loc_72DE
                moveq   #0,d3
                move.l  d3,d1
                move.b  $10(a1),d3
                move.b  $C0(a1),d1
                eieioSTP
                clr.b   $C0(a1)
                eieioSTP
                btst    #0,d1
                bne.s   loc_7300
                btst    #1,d1
                beq.s   loc_731C
                bra.s   loc_7308

loc_7300
                move.b  d3,fDBCmd(a3)
                move.b  d3,$16E(a3)

loc_7308
                clr.b   $163(a3)
                moveq   #$10,d2
                suba.l  a2,a2
                and.b   $B0(a1),d2
                clr.b   $B0(a1)
                eieioSTP
                bra.s   loc_7386

loc_731C
                lea     $1AE(a3),a2
                moveq   #$1F,d2
                and.b   $B0(a1),d2
                move.b  d3,(a2)+
                move.b  d3,d0
                lsr.b   #4,d0
                andi.l  #$F,d0
                btst    #5,fDBFlag(a3)
                bne.s   loc_7354
                btst    #2,d1
                beq.s   loc_7354
                bset    #6,fDBAuFlag(a3)
                move.w  DevMap(a3),d1

loc_734A
                addq.b  #1,d0
                andi.b  #$F,d0
                btst    d0,d1
                beq.s   loc_734A

loc_7354
                move.b  d0,PollAddr(a3)
                moveq   #$10,d1
                and.b   d2,d1
                bclr    #4,d2
                clr.b   $163(a3)
                subq.b  #1,d2
                move.b  d2,$163(a3)
                move.b  d2,d0
                or.b    d1,d2
                subq.b  #1,d0
                bmi.s   loc_7386
                movea.l a2,a0
                move.l  a1,d1
                lea     $20(a1),a1

loc_737A
                move.b  (a1),(a0)+
                lea     $10(a1),a1
                dbra    d0,loc_737A
                movea.l d1,a1

loc_7386
                bclr    #0,(a1)
                eieioSTP
                bclr    #4,d2
                bne.l   IMPLICITREQUESTDONE
                bclr    #2,fDBAuFlag(a3)
                bclr    #1,fDBAuFlag(a3)
                bne.l   IMPLICITREQUESTDONE
                bra.l   EXPLICITREQUESTDONE
; End of function sub_72C6



AlphaDebugPoll

                movea.l ADBBase,a1
                movea.l DeviceBase(a1),a1
                tst.l   a1
                beq.s   locret_73C4
                btst    #0,(a1)
                beq.s   locret_73C4
                pea     sub_72C6

locret_73C4

                rts


AlphaDebugEnter

                movea.l ADBBase,a0
                movea.l DeviceBase(a0),a1
                tst.l   a1
                beq.s   locret_73E2
                bset    #0,$E0(a1)
                eieioSTP
                bne.s   locret_73E2
                bset    #6,fDBAuFlag(a0)

locret_73E2

                rts

AlphaDebugExit

                movea.l ADBBase,a0
                movea.l DeviceBase(a0),a1
                tst.l   a1
                beq.s   locret_7400
                bclr    #6,fDBAuFlag(a0)
                beq.s   locret_7400
                bclr    #0,$E0(a1)
                eieioSTP

locret_7400

                rts
		ENDIF								; {1, Alpha}



		IF 1 THEN
;•••••••••••••••••••••••••••••••••••• Dummy •••••••••••••••••••••••••••••••••••••


;________________________________________________________________________________________
;
; Routine:	DummyInitADB
;________________________________________________________________________________________

DummyInitADB
                movea.l ADBBase,a3
                lea     loc_7410,a0
                move.l  a0,$130(a3)
                rts
loc_7410
                moveq   #0,d2
                movea.l d2,a2
                tst.l   d3
                bmi.s   locret_741E
                bra.l   EXPLICITREQUESTDONE
locret_741E
                rts
		ENDIF								; {1, Dummy}



		IF 1 THEN
;•••••••••••••••••••••••••••••••••••• Beta •••••••••••••••••••••••••••••••••••••


;_______________________________________________________________________________________
;
; Routine:	BetaInitADB
;
; Inputs:	Does not assume that A3 points to ADBBase, because called from InitADB!
;_______________________________________________________________________________________

				export  BetaInitADB ; for direct ADB Manager call
BetaInitADB
                lea     loc_7560,a0
                move.l  a0,([ExpandMem],$298)
                lea     BetaADBTable,a0 ; yes, my parent table!
                movea.l UnivInfoPtr,a1
                suba.l  a1,a0
                move.l  a0,$48(a1)
                movea.l ADBBase,a3
                bclr    #5,fDBFlag(a3)
                lea     loc_744E,a0
                move.l  a0,$130(a3)
                rts

loc_744E
                movem.l d0-d3/a3-a4,-(sp)
                tst.l   ([ExpandMem],$294)
                beq.s   loc_746E
                movea.l ([ExpandMem],$294),a1
                jsr     (a1)
                cmpi.l  #$FFFFFFFF,d0
                bne.s   loc_74AC

loc_746E
                move.w  ([ExpandMem],$2A0),d0
                cmpi.w  #$1234,d0
                bne.s   loc_7486
                movea.l ([ExpandMem],$2A0),a0
                bra.s   loc_749C

loc_7486
                tst.l   ([ExpandMem],$29C)
                beq.s   loc_74AC
                movea.l ([ExpandMem],$29C),a1
                moveq   #3,d0
                jsr     (a1)

loc_749C
                movem.l (sp)+,d0-d3/a3-a4
                tst.l   a0
                beq.s   locret_74AA
                movea.l ADBBase,a3
                jsr     (a0)

locret_74AA
                rts

loc_74AC

                movea.l d0,a2
                movem.l (sp)+,d0-d3/a3-a4
                moveq   #0,d2
                move.b  (a2)+,d2
                bra.l   EXPLICITREQUESTDONE


;_______________________________________________________________________________________
;
; Routine:	BetaDebugPoll
;_______________________________________________________________________________________

BetaDebugPoll
                tst.l   ([ExpandMem],$290)
                beq.s   loc_74D8
                movem.l d1-d2/a0-a1,-(sp)
                movea.l ([ExpandMem],$290),a1
                jsr     (a1)
                movem.l (sp)+,d1-d2/a0-a1

loc_74D8
                tst.l   ([ExpandMem],$29C)
                beq.s   locret_74F8
                movea.l ([ExpandMem],$29C),a1
                moveq   #4,d0
                jsr     (a1)
                move.l  $10(a0),d0
                beq.s   locret_74F8
                adda.l  d0,a0
                jsr     (a0)

locret_74F8

                rts


;_______________________________________________________________________________________
;
; Routine:	BetaDebugEnter
;_______________________________________________________________________________________

BetaDebugEnter
                tst.l   ([ExpandMem],$29C)
                beq.s   locret_7530
                movea.l ([ExpandMem],$29C),a1
                moveq   #4,d0
                jsr     (a1)
                move.l  8(a0),d0
                beq.s   loc_751A
                adda.l  d0,a0
                jsr     (a0)

loc_751A
                tst.l   ([ExpandMem],$29C)
                beq.s   locret_7530
                movea.l ([ExpandMem],$29C),a1
                moveq   #1,d0
                jsr     (a1)

locret_7530

                rts


;_______________________________________________________________________________________
;
; Routine:	BetaDebugExit
;_______________________________________________________________________________________

BetaDebugExit
                tst.l   ([ExpandMem],$29C)
                beq.s   locret_755E
                movea.l ([ExpandMem],$29C),a1
                moveq   #2,d0
                jsr     (a1)
                movea.l ([ExpandMem],$29C),a1
                moveq   #4,d0
                jsr     (a1)
                move.l  $C(a0),d0
                beq.s   locret_755E
                adda.l  d0,a0
                jsr     (a0)

locret_755E

                rts

loc_7560
                movea.l #$12345678,a0
                cmpa.l  a0,a1
                beq.s   loc_758C
                movea.l a1,a0
                _RmvTime
                movea.l ADBBase,a3
                lea     $1AC(a3),a2
                move.b  #2,(a2)+
                move.b  #$35,(a2)+
                move.b  #$FF,(a2)+
                lea     $1AC(a3),a2
                move.l  #$8000002C,d3

loc_758C
                movea.l ADBBase,a3
                moveq   #0,d2
                move.b  (a2)+,d2
                bra.l   IMPLICITREQUESTDONE
		ENDIF								; {1, Beta}



;•••••••••••••••••••••••••••••••••••• Miscellaneous •••••••••••••••••••••••••••••••••••••


		IF hasOrwell THEN					;													<H2>
;________________________________________________________________________________________
;
; Routine:	QuadraDebugPoll
;
; Inputs:	none
;
; Outputs:	none
;
; Trashes:	A1, D0, D1
;
; Function:	checks if the Caboose-style keyswitch is in the POWER OFF position, and if
;			so, turns the system off.
;
;			NOTE: A side effect of reading the keyswitch (VIA2, vBufB) is that if there
;				  are any pending sound interrupts, they'll be cleared in the VIA (design
;				  flaw?).  Therefore, if there are any pending interrupts, it will diddle
;				  with Batman to regenerate the interrupt in the VIA.
;________________________________________________________________________________________

QuadraDebugPoll
			MOVEQ	#v2PowerOff,D1			; which bit to test in VIA2 vBufB
			BSR.S	QuadraCheckKeyswitch	; is the keyswitch in the POWER OFF position?
			BNE.S	IOPRunKBD				; -> no, go do the keyboard polling

@PowerOff	_PowerOff						; kill the power
			BRA.S	@PowerOff


;________________________________________________________________________________________
;
; Routine:	QuadraCheckSecure
;
; Inputs:	A3	-	pointer to ADBBase
;
; Outputs:	CCR	-	BNE: call the handler, BEQ: skip it
;
; Trashes:	A1, D0, D1
;
; Function:	checks if the Caboose-style keyswitch is in the SECURE position (and if so,
;			the ADB Manager won't call the device completion routines)
;
;			NOTE: A side effect of reading the keyswitch (VIA2, vBufB) is that if there
;				  are any pending sound interrupts, they'll be cleared in the VIA (design
;				  flaw?).  Therefore, if there are any pending interrupts, it will diddle
;				  with Batman to regenerate the interrupt in the VIA.
;________________________________________________________________________________________

QuadraCheckSecure
			MOVEQ	#v2Keyswitch,D1			; which bit to test in VIA2 vBufB

QuadraCheckKeyswitch
@switchOffset EQU	$80						; bit 7 is a don't care to the VIA2 decode

			MOVEA.L	VIA2,A1					; point to VIA2
		eieioSTP
			MOVE.B	vBufB+@switchOffset(A1),D0	; read the keyswitch register, clearing interrupts (GAG)
		eieioSTP
			BTST	#ifCB1,vIFR(A1)			; do we think a sound interrupt is still pending?
		eieioSTP
			BNE.S	@HaveInt				; -> yes, we're done

			MOVEA.L	ASCBase,A1				; point to Batman
			CMPA.L	#-1,A1					; is it setup yet?
			BEQ.S	@HaveInt				; -> no, bail

			MOVE	SR,-(SP)				; save the status register
			ORI		#NoIntMask,SR			;  and disable all interrupts

		eieioSTP
			TST.B	bmIntControlA(A1)		; is the channel A interrupt enabled?
		eieioSTP
			BNE.S	@NoChannelA					; -> no
		eieioSTP
			MOVE.B	#1,bmIntControlA(A1)	; disable channel A interrupts,
			NOP								;  give Batman time to process the disable,
			CLR.B	bmIntControlA(A1)		;   and clear the interrupt mask to regenerate

@NoChannelA	
		eieioSTP
			TST.B	bmIntControlB(A1)		; is the channel B interrupt enabled?
		eieioSTP
			BNE.S	@NoChannelB				; -> no
		eieioSTP
			MOVE.B	#1,bmIntControlB(A1)	; disable channel B interrupts,
			NOP								;  give Batman time to process the disable,
			CLR.B	bmIntControlB(A1)		;   and clear the interrupt mask to regenerate
		eieioSTP

@NoChannelB	MOVE	(SP)+,SR				; restore the status register

@HaveInt	BTST	D1,D0					; test the bit we're interested in (0 = switch on)
			RTS


		ENDIF								; {hasOrwell}


			END
