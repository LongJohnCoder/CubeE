;
;	File:		SizeMem.a
;
;	Written by:	Gary Rensberger
;
;	Copyright:	Â© 1989-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	  <SM49>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
;									machines.
;	  <SM48>	11/19/93	KW		copied HMCMerge EDisk calculations and put in OrwellMerge.  Only
;									effects the CygnusX1 ROM
;	  <SM47>	11/17/93	chp		Put back TNT code inadvertantly removed by a previous checkin.
;	  <SM46>	11/17/93	KW		added some forSTP601 conditionals.  Only effects CygnusX1 ROM
;	  <SM45>	11/13/93	SAM		Roll in <MC10> from mc900ftjesus.
;	  <MC10>	11/13/93	SAM		In the EDisk calculation from the previous revision, I was not
;									anticipating the result going negative. It does. I now check for
;									it.;	  <SM44>	11/12/93	SAM		Roll in <MC9> from mc900ftjesus.
;	   <MC9>	11/12/93	SAM		When allocating an EDisk, make sure there is KminHeap (or
;									somesuch) free or don't allocate.    The ammount of RAM
;									allocated for the edisk is stored beyond the diagnostic longs at
;									the end of the chunk table.  InitMMU uses this size for eMMU
;									machines.
;	  <SMG2>	 11/9/93    fau     Added the TNT Decoder support (HammerHead)
;	  <SM42>	 11/9/93	KW		added some conditional forSTP601.  Only used for CygnusX1 ROM
;	  <SM41>	 11/7/93	SAM		Roll in <MC8> from mc900ftjesus.
;	   <MC8>	 11/7/93	SAM		Keep a running total of RAM allocated by the nanokernel in the
;									chunk table.
;	  <SM40>	 11/6/93	SAM		Roll in <MC7> from mc900ftjesus.
;	   <MC7>	 11/6/93	SAM		Disable Sonora video before mucking with the NanoKernel memory
;									allocation.
;	  <SM39>	 11/1/93	SAM		Roll in <MC6> from mc900ftjesus.
;	   <MC6>	 11/1/93	SAM		(RC) HMCMerge now checks PRAM for the diag burn-in sig as well
;									as reading the monitor sense lines for the RBV to determine if a
;									DRAM based frame buffer should be allocated.
;	  <SM38>	10/16/93	SAM		Roll in <MC5> from mc900ftjesus.
;	   <MC5>	10/16/93	SAM		Add some slop to the RBV buffer for PDM to account for QD
;									writing past the end of the buffer. (Doesn't this seem like a
;									problem to you?  Does to me...)
;	  <SM37>	10/15/93	SAM		Roll in <MC4> from mc900ftjesus.
;	   <MC4>	10/15/93	SAM		Ok, I fixed the boot beep code, so the RBV size is now set to a
;									max of 600k (not 768).  Removed the 3 extra longs allocated in
;									the chunk table (for debugging).
;	  <SM36>	 9/29/93	SAM		For PDM: from mc900ftjesus.
;	   <MC3>	 9/25/93	SAM		For PDM: Loose Evt1 support.
;	  <SM35>	 9/13/93	SAM		For PDM (HMC): Removed the Edisk hack for the nanokernel.
;									Marked all the DMA buffers noncacheable.
;	  <SM34>	  9/9/93	pdw		Added 'nk' onto front of MakePageWriteThrough.
;	  <SM33>	 8/23/93	SAM		Added a temp hack to increase the amount of RAM allocated for
;									the RAM disk by 1 page (nk bug)
;	  <SM32>	 8/23/93	SAM		Changed the alignment restriction for the EDisk allocation to be
;									4k.
;	  <SM31>	 8/23/93	SAM		Added some space in the HMC chunk table for a couple of
;									warmstart longs.
;	  <SM30>	 8/12/93	KW		adding two more smurf wombats
;	  <SM29>	 8/11/93	KW		added some branches based on new smurf boxes
;	  <SM28>	 6/14/93	kc		Roll in Ludwig.
;	   <LW4>	  6/4/93	fau		In sizing memory in Cyclone, there was a bug when a Wide Mode
;									SIMM was in bank 5, no SIMM in bank 7, and a Standard Mode SIMM
;									in Bank 0.  Bug #1088829.
;	  <SM27>	  6/3/93	SAM		For HMC machines (PDM) if an evt2 or better is found, the floppy
;									and serial DMA buffers are marked noncacheable in order fix a
;									data path snooping during DMA bug.
;	  <SM26>	  5/9/93	SAM		Added a couple lines of crucial code to the PDM physical buffer
;									allocation code.  Grin.
;	  <SM25>	  5/6/93	SAM		For PDM.  Changed the HMC entry in the sizemem "split" table to
;									point directly at the HMCMerge routine (we don't have to size
;									anything, really).  Addded allocation of the DMA and video frame
;									physical buffers to HMCMerge.  Added code to make the frame
;									buffer write-through cacheable.
;	  <SM24>	 4/30/93	SAM		Removed non-functional non-universal forRomulator code in
;									SizeBanks (<LW2>).  Added one more forSmurf condo.
;	  <SM23>	 4/19/93	SAM		Added forSmurf conditionals around RiscWombat boxflag check
;									(ugh).
;	  <SM22>	 3/31/93	chp		Synchronize SuperMario with changes from <LW2>.
;	  <SM21>	 3/11/93	SAM		Added EDisk allocation to HMC merge code.
;	   <LW2>	 2/26/93	fau		Removed Cyclone EVT3 (MMC) support.
;	  <SM20>	 2/25/93	RC		Fixed Merge code for Smurf.  Old code did not do what we thought
;									it did, but now it correctly sizes memory by using the same code
;									and PDM uses.
;	  <SM19>	 2/20/93	SAM		Added emuWarmStartConst to the chunk table build for HMC
;									machines.
;	  <SM18>	  2/5/93	SAM		Added HMC "merge" code that conconcts a fake chunk table and
;									generally does the right thing.  (for PDM).
;	  <SM17>	12/23/92	RC		Added Support for Smurf
;	  <SM16>	 12/1/92	EH		Changed PrattAddr reference to DecoderAddr reference for
;									PrattMerge.
;	  <SM15>	 12/1/92	EH		Added code for Pratt memory controller.
;	  <SM14>	11/12/92	rab		Added djMEMCSplit to the split table (had added the code but
;									forgot the entry). Also exported SizeSoundBuffer for MMUTable.a.
;	  <SM13>	11/10/92	GD		Fixed some "forRomulator" issues from latest Horror roll-in.
;	  <SM12>	 11/3/92	rab		Roll in Horror changes. <H16>10/13/92 BG Modified various
;									comments in the djMEMCSplit code to indicate that both WLCD and
;									Primus need to set the OneBufferedBus bit. <H15> 9/28/92 BG
;									Changed the djMEMCMerge code so that if you are trying to create
;									a ReAnimator type ROM, don't turn on memory interleaving. <H14>
;									8/4/92 SWC Fixed a bug in MSCMerge: we were only allocating
;									enough space for 5 RAM banks (we support 8), so the end of the
;									RAM chunk table was going into write-only RAM.
;	 		<H13> 7/13/92	SWC		Added some code to the end of MergeDone to move the RAM chunk
;									table below a sound buffer in high RAM. This was moved here from
;									MMUTables.a because (1) since the chunk table was moved down
;									after running StartTest, we'd lose the warmstart flag (causes
;									the RAM disk to get trashed on Restart, and (2) diagnostics seem
;									to call SizeMem in several places, so I figured it was better to
;									get everything set up once.
;	  		<H10> 6/16/92	BG		Added back in the interleave initialization for djMEMC.
;									However, a precursor check has been added to only allow that
;									code to be executed if the version number of djMEMC is greater
;									than 0, since version 0 parts will cause Wombat/WLCD to die
;									shortly after enabling interleaving.
;			<H8> 6/12/92	BG		Added support for sizing up to 16 banks of memory. This is
;									needed because Wombat can support up to 10 banks. Also - removed
;									the djMEMC configuration register initialization from here and
;									moved it to UniversalPatch.a so that it is not executed multiple
;									times (since SizeMemory gets called multiple times).
;			<H7>	 6/9/92	BG		Added djMEMC memory controller to split and merge tables, as
;									well as the split and merge code. However, changes to SizeBanks
;									are also required that have not been fully tested on all
;									machines yet, so that did _not_ get rolled in.
;			<H6> 5/20/92	NJV		Fixed register-trashing bug in SonoraMerge.
;			<H5> 5/19/92	SWC		Modified @MSCSplit and MSCMerge to temporarily support both MSC2
;									and MSC3 while we make the transition.
;       	<H4> 5/12/92	HY		Roll-in LC II changes.  Change the sizing routine for VISA 
;									decoders to support 2 or 4MB on PCB.
;			<H3>  5/4/92	JC		Change Sonora split so that Bank 0 has 4 Megs of RAM installed.
;			<H2> 4/13/92	JC		Remove references to SonoraAddr (is going away) and replaced
;									with references to RBVAddr for Sonora based machines.
;	  <SM11>	10/22/92	fau		Added support for the YMCA Decoder in standard and wide mode.
;									This involved adding a new YMCASize banks.  Added a check to
;									SizeBank to make sure we didn't spin forever if the ram bank end
;									is not a multiple of 2^(n-1) * chunksize.  (This will occur when
;									sizing wide memory as standard memory).  Also, changed the use
;									of MMC/YMCAExists and MMC/YMCAAddr to use the decoder info.
;	  <SM10>	10/18/92	CCH		Added support for HMC decoder.
;	   <SM9>	 9/30/92	fau		Incorporated support for the YMCA decoder that is found in
;									Cyclone EVT4.  This included the YMCA split routine and the
;									YMCAMerge routine.  Left the support for the MMC in there.
;									Eventually, the MMC (used in previous Cyclone EVT's, should go
;									away.)
;	   <SM8>	 8/19/92	CSS		Update from Reality:
;									<23> 8/18/92 DTY	Change the name of BootGlobs to StartGlobals to avoid confusion
;														with BootGlobals, which is used by the boot code in Boot[1-3].a.
;	   <SM7>	 8/17/92	CCH		Changed orwell stitch code to use DecoderAddr field instead of
;									OrwellAddr.
;	   <SM6>	 8/11/92	kc		Don't split memory while running the ROM image in RAM on
;									Cyclone. Use A3 instead of A7 in SizeMem to make ReAnimator
;									happy.
;	   <SM5>	  8/9/92	CCH		Don't attempt to stitch memory when running on a RISC processor
;									in a Quadra.
;	   <SM4>	 7/13/92	CCH		Added conditionalized support for Cub Card on Quadras.
;	   <SM3>	 5/25/92	RB		Making Cyclone changes...Pandora/Horror comments follow: <P4>
;									5/13/92 KW (HV,H4) Roll-in LC II changes. Change the sizing
;									routine for VISA decoders to support 2 or 4MB on PCB. (JC,H3)
;									Change Sonora split so that Bank 0 has 4 Megs of RAM installed.
;									<P2> 3/4/92 RMP Changed MMCMerge to configure Bank B correctly.
;									<H5> 5/19/92 SWC Modified @MSCSplit and MSCMerge to temporarily
;									support both MSC2 and MSC3 while we make the transition.
;	   <SM2>	 5/16/92	kc		Roll in Horror and Terror Changes. Comments follow:
;	   <H13>	01/27/92	jmp 	The original contents of this file have been moved to the
;									SizeMemPatch.a file.
;		<H9>	 12/9/91	SAM 	Added a read to ROM in SizeBank between the RAM write and compare
;									to prevent a floating bus from fooling us into thinking that
;									there are 4 gigabytes of RAM built-in.
;		<H7>	 12/5/91	SAM 	Removing all special cases for built-in RAM for Vail machines
;									cuz the hardware folks decided that their klude was a kludge.
;		<H5>	 12/3/91	SAM 	Changed Sonora split/merge code to use the new SonoraVIA2
;									base address equate.
;		<H4>	11/25/91	SAM 	First attempt at the Sonora sitch routine for Vail and
;									Carnation.
;		<H3>	10/22/91	SWC 	Changed MSCAddr references to RBVAddr since MSC is just a
;									variant of the RBV.
;		<H2>	  8/5/91	SWC 	Added a fix to MSCMerge so that it works correctly if all RAM
;									banks are not filled.
;		<T9>	 6/21/91	BG		Swapped the order of the case table in SizeMemory to match the
;									(new) order of the DecoderKinds table in UniversalEqu.a.
;		<T7>	  5/1/91	HJR 	SWC - Added support for the MSC for DB-Lite.
;		<T4>	 11/7/90	BG		Made changes for new rev. of Orwell (2) permanent.
;		<22>	12/29/91	RB		Added Terror changes.
;		<21>	 9/16/91	JSM		Cleanup header.
;		<20>	 6/12/91	LN		removed #include 'HardwareEqu.a'
;		<19>	  3/5/91	dba		put in an align directive so that we donât get a warning
;		<18>	  3/5/91	PN		Fix the warning by putting the END statement at the end
;		<17>	 9/24/90	GMR		Added special case to JAWS merge code to deal with 2 meg bank A,
;									0 meg bank B and vice versa when the 2 meg is in a single chunk
;									(as in TIM).
;		<16>	 9/19/90	BG		Removed 040-related kludges (EclipseNOPs).
;		<15>	  8/2/90	CCH		Clear D6 error flag after chunk table is written.
;		<14>	 7/10/90	CCH		Fixed bug in orwell merge, and modified it to create a separate
;									chunk table entry for each chunk listed in universal.a.
;		<13>	 5/10/90	GMR		Preserved reg d2 inside FMCMerge.
;		<12>	  5/3/90	GMR		Fixed file contents- ROMLister corrupted the file before
;									check-in.
;		<11>	  5/3/90	GMR		The chunk table now contains separate, contiguous chunks for
;									each bank of RAM.
;		<10>	 4/25/90	GMR		Made previous change save register A4, as before.
;		 <9>	 4/21/90	GMR		Moved ConfigureRAM functionality from StartInit.a to this file,
;									to fix problems associated with writing the chunk table before
;									the memory is stitched together. The sizing code now can size up
;									to 8 banks before storing the info in the chunk table. Added
;									Waimea splitting/stitching code to deal with it's 8 banks of
;									RAM.
;		 <8>	  4/2/90	JJ		Correct memory address used to distinguish between Elsies with 1
;									MB vs 2 MB on main logic board.
;		 <7>	 3/23/90	JJ		Added code to handle Elsie VISA 2 setting of size bits.
;		 <6>	 2/28/90	JJ		Added code to initialize memory size bits for machines with VISA
;									decoders.
;		 <5>	 2/21/90	BG		The Orwell configuration code needed a small bit of tweaking.
;		 <4>	 2/16/90	BG		Added code to initialize Orwell bank addresses to the known
;									default power-on state.
;		 <3>	 1/11/90	CCH		Added include of âHardwarePrivateEqu.aâ.
;	   <2.9>	 10/9/89	GMR		NEEDED FOR ZONE5: Return bit mask for bad byte lanes, supporting
;									up to 8 banks of 4 byte lanes each. Initialize FMC to put bank B
;									on 64 Meg boundary.
;	   <2.8>	 6/30/89	GMR		Put FF's on bus between byte compare write/read cycles, to
;									eliminate stray capacitance problems when no RAM present on
;									access.
;	   <2.7>	 6/26/89	GMR		Changed to exit with a real stack pointer near low memory, top
;									element on stack contains pointer to memory chunk table at top
;									of last bank.
;	   <2.6>	 6/11/89	GGD		Converted to use RamInfo in rom tables.
;	   <2.5>	 6/11/89	GMR		Changed call to GetHardwareInfo to be a BigBSR6 so it'll reach.
;	   <2.4>	 5/30/89	GMR		Added comment describing error code returned in D6
;	   <2.3>	 5/26/89	GMR		Return error, instead of ignoring bank, if only some SIMMs in a
;									bank are present. This should make Service happy.
;	   <2.2>	 5/26/89	rwh		changed to new improved BootGlobs field names.
;	   <2.1>	 5/22/89	GMR		Corrected prep of d2 before GetHardwareInfo call, optimized a
;									few things, terminated tables with 1 long instead of 2 longs.
;	   <2.0>	 5/16/89	GMR		Rewrote entire file, returning a7 pointing to table of bank
;									entries (start,length,...,$FFFF) on all machines. It's now
;									non-destructive.
;									---------------Below doesn't apply now---------------
;==============================================================================================
;	   <1.9>	 4/28/89	rle		check startup code (now in d5) upon entry to determine if stack
;									is valid or memory needs to be tested
;	   <1.8>	 3/28/89	SES		Cleaned up code to run a bit more efficiently. Added an initial
;									browse through memory so that we can run out of Bank B only for
;									HafMac.
;	   <1.7>	  3/7/89	SES		Added code to check for warm start and PwrMgr reset before
;									running Ram test.
;	   <1.6>	 2/24/89	SES		Added code to ensure screen is clean for RBV-based machines.
;	   <1.5>	 2/23/89	SES		Mixed conditional for EXPORT BankASize to reflect what's in the
;									body of routine.
;	   <1.4>	 2/22/89	SES		Added non-destructive code back in. Added check for startup or
;									entry from booted system. Changed stack and table setup to be a
;									bit more flexible. Still need to add a search for where first
;									RAM is.
;	   <1.3>	 2/16/89	rwh		Added support for Fitch Memory Controller rev 1. When FMC2
;									arrives, may need to change these for a contiguous physical
;									memory model. Removed MvMac hack in SizeMem.
;	   <1.2>	 2/16/89	SES		Removed non-destructive code because restored values end up
;									writing via wrap into locations that haven't been checked yet.
;	   <1.1>	 2/15/89	SES		Fixed routine so that it is non-destructive. On exit, stack will
;									be set to the top of tested memory.
;	   <1.0>	 2/13/89	SES		Adding to EASE for the first time.
;
;_____________________________________________________________________________________________

		PRINT		OFF
		LOAD		'StandardEqu.d'
		INCLUDE		'HardwarePrivateEqu.a'
		INCLUDE		'UniversalEqu.a'
		INCLUDE		'STEqu.a'
		INCLUDE		'MmuEqu.a'
		INCLUDE		'BootEqu.a'
		INCLUDE		'EDiskEqu.a'
		INCLUDE		'DepVideoEqu.a'
		PRINT		ON
		STRING		ASIS

		PROC

		IMPORT		GetHardwareInfo, RdXByte,RamInfoPrattFlash
		EXPORT		SizeMemory
		EXPORT		SizeSoundBuffer		; <SM14>
		MACHINE		MC68020

;_____________________________________________________________________________________________
; Routine:	SizeMemory
;
; Inputs:	none
;
; Outputs:	a7 - initialized stack pointer (if RAM found), top element points to
;				 memory table of size blocks found.
;			d6 - result code, 1 nibble/bank, 1 bit set for each SIMM bad in bank:
;					= 00000000 if RAM sized ok
;					= 00000001 if SIMM 0 in bank A is bad
;					= 0000000F if SIMMs 0,1,2,3 in bank A are bad
;					= 00000020 if SIMM 1 in bank B is bad
;
;						NOTE!! D6 only holds error information for the first 8 banks!			<H8>
;
; Uses:		a0 - Ptr to table of base addresses
;			a1 - Ptr to product info record
;			d0
;
; Destroys:	d0-d5,a0-a3,a5
;
;  This file contains the universal size memory routine, which sizes memory banks
;  for all machines and returns a table of start/size records for each bank found.
;  It assumes data cache is off, and no MMU translation.
;  The table is located at the top of the last bank of RAM found, and the entries
;  have the following format:
;
;						A7 -->		(pointer to chunk table)            -----
;																			|
;																			|
;					 ChunkTable:	start.L,length.L		{ bank A }  <----
;									start.L,length.L		{ bank B }
;									...						{ bank n }
;									$FFFFFFFF
;_____________________________________________________________________________________________
		WITH DecoderInfo,DecoderKinds,StartGlobals, RAMBankInfo						; <SM3> rb <SM8> CSS

SizeMemory
			move.l	a6,a2						; save return address
			bra		PowerPCMerge
			Align	4
; (CDG5) Code removed but comments kept for context




;=============================================================================================
;																										<SM11> fau start
YMCASizeBanks
;
;	The YMCA has a separate SizeBanks routine because it supports standard and wide mode DRAM SIMMs.  (See
;	the YMCA ERS).  Wide Mode DRAMs have more rows than columns and use less power -- Wombat uses these too.
;   But, we're different and we support the standard mode, where the # of rows and columns are the same.  What
;   this means is that in order to size the banks we have to go through the sizing routine twice:  once with
;   the memory controller addressing the SIMMS in standard mode, and once in wide mode. (Note:  The YMCA ERS
;   has this complicated roadmap to follow in order to size the memory.  After reviewing and looking at the
;   DRAMs we support I determined that we can size the memory by making the two passes (standard and wide) and
;   then comparing the nibble sizes for each bank and taking the largest one).  One has to be careful because
;   the standard/wide mode is programmed by bank pair:  0/2, 1/3, 4/6, and 5/7.  Any bank can be populated, thus
;   have to watch out for nibble sizes of 0.  Well, enough of this.  FAU 10/21/92

; (CDG5) Code removed but comments kept for context
;																											<SM11> fau end
;_____________________________________________________________________________________________
; Routine:	SizeBank
;
; Inputs:	a0 	- points to start of physical bank to size
;			a1 	- points to end   of physical bank to size
;			a2	- SizeMem return address
;		   (a5)	- page size to check for aliasing (e.g. 1 meg)
;			d0	- total RAM from previous banks sized
;			d1 	- signature
;			d5 	- x......., where x = nibble sizes of previous bank(s) sized.
;
; Outputs:	d0	- total RAM including this banks size.
;			d5 	- x......n, where n = nibble size of this bank (0..15)
;			a0 	- actual size of bank
;
; Destroys:	a1,d2-d4
;
; Given the start and end of a bank of memory, this routine finds the last location
; within the bank which can be written to (including wrap).  Then it trims this back,
; checking for wrap. On exit, it sets a0 = actual size of unique RAM found in the bank,
; (0 if no RAM found), and the low nibble of d5 contains n where bank size = 2^(n-1)*chunk size
; for n > 0, and bank size = 0 for n=0.
;
; This routine assumes that the data cache is OFF.  The addresses passed in
; must be on page boundaries, where the page size is in D0.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context


;_____________________________________________________________________________________________
; Routine:	CheckByteLanes
;
; Inputs:	a0 	- location to check
;			d1 	- signature
;			d6 	- x......0 where x = running bit mask of previous bank(s) SIMM errors
;			a2	- SizeMem return address
;
; Outputs:	d6 	- x......e where e = bit mask for this banks errors:
;								 e = 0000 if byte lanes 0-3 seem  ok
;								 e = 0001 if byte lane  0   seems bad
;								 e = 1111 if byte lanes 0-3 seem  bad
;
; Destroys:	d2-d4
;
; This routine checks which byte lanes are valid at location pointed to by
; a0.  This helps service identify missing SIMMs, etc.  It can be called up
; to 8 times (for 8, 4-byte-wide banks) before overflowing the result register.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context





;=============================================================================================
; Routine:	Concat
;
; Inputs:	d0 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			d6	-	nibble sizes for up to an additional 8 banks						<H7><H8><SM12>
;			a2	-	SizeMem return address
;
; This routine vectors to the appropriate 'stitch' routine, after getting the decoder type.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context


;_____________________________________________________________________________________________
; Routine:	noMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to universal base addresses table
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d1,a1
;
; This routine simply writes the chunk table at the top of the bank (pointed to by a1), given
; the banks size in d0.  Used ONLY for single bank systems (like MacPlus, SE, Portable).
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context





;____________________________________________________________________________________________
; Routine:	PowerPCMerge (emulated system fake stitch and fake chunk table creation)
; Very similar to OrwellMerge, HMCMerge, HHEadMerge (whose comments are preserved below)
;____________________________________________________________________________________________
		export	PowerPCMerge

PowerPCMerge
		With	NKSystemInfo, ProductInfo, VideoInfo
		
		MOVEQ	#0,D5

; Read PRAM to see if the user wants an EDisk.  If the size is > MinRamDiskSize then ask the	<SM21> SAM
; nanokernel for some RAM.

		MOVE.L	A2,D3										; Save SizeMem's return address

		LongBSR6 GetHardwareInfo							; Get universal info again
		
		LSR.W	#8,D2										; Get the boxflag in the low byte	<SM27>
		MOVE.B	D2,D7										; Save it in D7						<SM27>
		
		MOVEQ	#0,D4										; unclear purpose
		MOVEQ	#1,D4

		MOVE.L	$68FFEFF0,A2								; Read the EDisk size (in % of total RAM) in D1
		MOVE.B	$128(A2),D1
		MOVE.L	D3,A2										; Restore the return address
					
; Get the MMU page size from the nanokernel.  Count bits in the result to get a shift factor

		MOVEQ	#0,D3										; Clear D3
		MOVE.L	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
		BFFFO	D0{15:15},D3								; Get the shift factor (Find First One)
		NOT.B	D3											; Flip the order (BF instr start at bit 32 -> )
		ADD.B	#32,D3										; Get the bit number (lsb based)

		MOVE.L	(NKSystemInfoPtr),A5						; Point to the nanokernel SystemInfo record
		ANDI.L	#$FF,D1										; Clear upper bytes of pram byte
		BEQ.S	@AfterRAMDiskCheck							; -> No EDisk
		
		MOVE.L	PhysicalMemorySize(A5),D2					; Get physical RAM size
		LSR.L	#8,D2										; Scale the size by 256k chunks
		MULU.L	D1,D2										; Mult Chunks by ChunkCount from PRAM = EDisk size
		ADD.L	#$7FFF,D2									; Add an extra 32k to the size
		AND.W	#$8000,D2									; Round down to 32k boundary
		CMPI.L	#MinRamDiskSize,D2							; Is this size too small? (user pulled some SIMMs)
		BCC.S	@notSml
		MOVE.L	#MinRamDiskSize,D2
@notSml	CMPI.L	#MaxRamDiskSize,D2
		BHI.S	@AfterRAMDiskCheck

		MOVE.L	PhysicalMemorySize(A5),D1
		SUBI.L	#$600000,D1
		CMP.L	D1,D2
		BLS.S	@consrv
		MOVE.L	D1,D2
@consrv	MOVE.L	D2,D5
		ADD.L	D2,D7

		MOVE.L	#bRamDisk,D0								; Get the EDisk logical base address
		LSR.L	D3,D0										; Turn the address into a page number
		MOVE.L	D0,A0										; Put the logical page number in A0

		LSR.L	D3,D2										; Turn the size into a page count
		MOVE.L	D2,A1										; Put page count in A1

		MOVEQ	#0,D1										; Indicate no special alignment necessary
		_nkAllocateMemory									; Get the RAM and map it where we asked

@AfterRAMDiskCheck
													;										End	<SM48>
************************************************************************
; Activate the Dynamically Recompiling Emulator

		MOVEQ		#19,D0										; Only if the low 2 bits of ECR19 == 01
		_MoveFromECR
		BNE		@Chunky
		MOVE.L	A0,D0
		AND		#3,D0
		CMP		#1,D0
		BNE		@Chunky

		MOVE.L	A2,D3										; save return addr around GetHardwareInfo
		MOVEQ	#0,D2										; tell it nothing
		BigBSR6	GetHardwareInfo								; single, insulated call
		MOVE.L	(NKSystemInfoPtr),A2						; reach totally unexpectedly into SystemInfo!
		MOVE.B	$129(A2),D1									; ...and get the number of Tcache pages
		MOVE.L	D3,A2										; restore return address
		MOVE.L	(NKSystemInfoPtr),A5						; restore clobbered A5 ptr

		MOVEQ	#0,D3										; Clear D3
		MOVE.L	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
		BFFFO	D0{15:15},D3								; Get the shift factor (Find First One)
		NOT.B	D3											; Flip the order (BF instr start at bit 32 -> )
		ADD.B	#32,D3										; Get the bit number (lsb based)

		LSR		#4,D1										; the number we got is (pages - 16)
		AND		#$F,D1										; and it had better be at least 16
		BZ.S	@Chunky

		ADDQ	#1,D1										; Calculate size of (number + 16) pages
		SWAP	D1
		CLR		D1
		ADD.L	D1,D7										; (add that to our running total)

		MOVE.L	D1,A0										; ECR22 = T-cache size
		MOVEQ	#22,D0
		_MoveToECR
		MOVE.L	#$69000000,A0								; ECR21 = T-cache pointer
		MOVEQ	#21,D0
		_MoveToECR

		MOVE.L	A0,D0										; Allocate memory for the T-cache
		LSR.L	D3,D0
		MOVE.L	D0,A0										; A0 = logical page number
		LSR.L	D3,D1
		MOVE.L	D1,A1										; A1 = page count
		MOVEQ	#0,D1										; D1 = no special alignment
		_nkAllocateMemory									; no error check!

		MOVEQ	#19,D0										; Set low bit of ECR19 to turn on DR!
		_MoveFromECR
		MOVE.L	A0,D1
		BSET	#1,D1
		MOVE.L	D1,A0
		_MoveToECR

; Now that RAM has been adjusted by the possible allocation of an EDisk, Video frame buffer
; and/or DMA buffer, we can construct the RAM chunk table that sits at the top of logical RAM.
; At this point A5 should be pointing to the nanokernel SystemInfo record.
		
@Chunky	MOVE.L	UsableMemorySize(A5),D1						; Get the Useable RAM size from NK
		MOVE.L	D1,A5										; Put the size (our Memtop) in A5

															; Start from the Top down
		MOVE.L	D7,-(A5)									; Put our total allocation at the top of L RAM (Inc edisk). <MC8>
		MOVE.L	D5,-(A5)									; Num bytes used by the EDisk								<MC8>
		MOVE.L	#$45676773,-(A5)							; Diag long #3
		MOVE.L	#$616E6420,-(A5)							; Diag long #2
		MOVE.L	#$53616D20,-(A5)							; Diag long #1
		MOVE.L	#-1,-(A5)									; Chunk table terminator
		MOVE.L	D1,-(A5)									; Top of usable RAM
		CLR.L	-(A5)										; Logical start of RAM

		MOVE.L	A5,A1										; Put Ptr to chunk table in A1 for MergeDone
		MOVEQ	#0,D6										; Signal no RAM test errors.
		BRA		MergeDone									; Set the stack and leave

		EndWith



;_____________________________________________________________________________________________
; Routine:	HMCMerge (emulated system fake stitch and fake chunk table creation)				<SM18> Sam
;
; Inputs:	none
;
; Outputs:	a5	-	points to the chunk table
;			a1	-	Ptr to product info record
;
; Destroys:	D0-D3/D6,A0-A2
;
; This routine creates a fixed size chunk table at the end of logical RAM.  The emulator provides
; us with the size of logical and physical RAM.  The logical size accounts for the RAM stolen by
; the emu for DMA buffers, video, EDisk, etc.  The Physical size is useful only for display at the
; Finder, etc.  Oh, yes, by the time we get run (68k code, that is) the native hardware init has
; already sized and stitched memory together.
;
; The fake table looks like this:
;
;	1st bank start addr:							$00000000
;	Length (log ram size returned from the emu)		0 < X <= 256mb
;	Chunk table terminator							$FFFFFFFF
;	Std diagnostic long #1							$00000000
;	Std diagnostic long #2							$00000000
;	Std diagnostic long #3							$00000000	
;	Total bytes allocated for an EDisk				$xxxxxxxx
;	Total RAM allocated by the nanokernel			$xxxxxxxx	; The end of "Physical RAM"
;
; Table size: $20 bytes fixed.
;
; D7 is used as a flag register for the size of the RAM Disk and whether or not to allocate Video RAM
; 				bit 31: high = allocate Video RAM (bit is cleared when testing to turn on video or not)
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context


;_____________________________________________________________________________________________
; Routine:	HHEadMerge (emulated system fake stitch and fake chunk table creation)				<SM18> Sam
;
; Inputs:	none
;
; Outputs:	a5	-	points to the chunk table
;			a1	-	points to the chunk table
;
; Destroys:	D0-D3,A0-A2
;
; This routine creates a fixed size chunk table at the end of logical RAM.  The emulator provides
; us with the size of logical and physical RAM.  The logical size accounts for the RAM stolen by
; the emu for DMA buffers, video, EDisk, etc.  The Physical size is useful only for display at the
; Finder, etc.  Oh, yes, by the time we get run (68k code, that is) the native hardware init has
; already sized and stitched memory together.
;
; The fake table looks like this:
;
;	1st bank start addr:							$00000000
;	Length (log ram size returned from the emu)		0 < X <= 256mb
;	Chunk table terminator							$FFFFFFFF
;	Std diagnostic long #1							$00000000
;	Std diagnostic long #2							$00000000
;	Std diagnostic long #3							$00000000	; The end of "Physical RAM"
;
; Table size: $24 bytes fixed.
;
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context



;_____________________________________________________________________________________________
; Routine:	GlueMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d1,d3,a1,a5
;
; This routine stitches banks A,B together for the MacII's glue chip decoder.  It then writes
; the chunk table at the top of RAM.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context



;_____________________________________________________________________________________________
; Routine:	MDUMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d3,a1,a5
;
; This routine writes the chunk table (containing 1 or 2 entries) at the top of the highest bank,
; for the Mac IIci's MDU decoder (no stitching possible with this one).
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context




;_____________________________________________________________________________________________
; Routine:	FMCMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d2,a1,a5
;
; This routine stitches banks A,B together for the Mac IIfx's FMC decoder.  It then writes
; the chunk table at the top of RAM.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context



;_____________________________________________________________________________________________
; Routine:	OrwellMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks (we only use the lower 4)
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d4,d6,a3,a5
;
; This routine stitches banks A,B,C,D together for Eclipse's Orwell decoder.  It then writes
; the chunk table at the top of RAM.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context

;_____________________________________________________________________________________________
; Routine:	SonoraMerge																			<SAM>
;
; Inputs:	D0 	- 	bases valid bits
;			D2	-	chunk size for this decoder
;			D3 	- 	total size of RAM in system
;			D5	-	nibble sizes for up to 8 banks
;			A0	-	ptr to table of base addresses
;			A1	-	ptr to universal RAMInfo table (first entry)
;			A2	-	SizeMem return address
;
; Outputs:	A5	-	points to the chunk table
;
; Destroys:	D0-D4,D6,A3,A5
;
; This routine stitches banks A,B,C,D and E together and sets the SIMM size
; bits for the two SIMM sockets for the Sonora decoder.
; It then writes the chunk table at the top of RAM.
;__________________
;
; Weirdness Notes:
;
; Supports two SIMMs.  Each with at most two banks of RAM.
;
; Carnation/Vail machines that have any RAM in bank 0/A (built-in)  must have the "Bank0Size" bit
; in the RAM Config register set to 1.
;
; Assumptions:
;	If there is no RAM in the first bank of each SIMM, then the other bank is assumed empty as well.
;	If RAM is found in the second bank of a SIMM it is assumed to be the same size as
;	the first bank.
;
;_____________________________________________________________________________________________

; (CDG5) Code removed but comments kept for context


;_____________________________________________________________________________________________
; Routine:	YMCAMerge																			<SM9> fau, start
;
; Inputs:	D0 	- 	bases valid bits
;			D2	-	chunk size for this decoder
;			D3 	- 	total size of RAM in system
;			D5	-	nibble sizes for up to 8 banks
;			A0	-	ptr to table of base addresses
;			A1	-	ptr to universal RAMInfo table (first entry)
;			A2	-	SizeMem return address
;
; Outputs:	A5	-	points to the chunk table
;
; Destroys:	D0-D4,D6,A3,A5
;
; This routine stitches banks 0 through 7 and sets the SIMM size
; bits for the eight banks for the YMCA decoder.
; It then writes the chunk table at the top of RAM.
;
;__________________
;
; Weirdness Notes:
;			TBD  
;_____________________________________________________________________________________________

; (CDG5) Code removed but comments kept for context

;																						<SM11> fau, end
;_____________________________________________________________________________________________
; Routine:	VISAMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d1,a5
;
; This routine stitches banks A,B together for Elsie's VISA decoder.  It then writes
; the chunk table at the top of RAM.
;
; Rewritten 5/12/92 (<H4>) to work with LC and LCII. This routine now assumes that the			<SM4> rb, start
; @VISASplit code has set the size bits correctly for bank B.  All we have to do here 
; is set the size bits for bank A only.  Couldn't use old routine because on LC II its 
; possible to have the same total RAM configuration but different size bit settings 
; (i.e. 6MB total = 2 MB on PCB + 2-2 MB SIMMs in bank A OR 4 MB on PCB and 2-1 MB SIMMs).
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context

;_____________________________________________________________________________________________
; Routine:	JAWSMerge/NiagraMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d1,d4,a5
;
; This routine stitches banks A-B-C-D,E-F-G-H together for Waimea's JAWS decoder.  It then writes
; the chunk table at the top of RAM.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context

;_____________________________________________________________________________________________
; Routine:	MSCMerge
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d1,a5
;
; This routine stitches banks A-H together for DB-Lite's MSC controller.  It then writes
; the chunk table at the top of RAM.  RAM banks 4-7 can either contain 2MB or 8MB of RAM.
; If bank 4 doesn't have 8MB of RAM, we'll assume the rest don't and clear the MSCBank8M
; bit in the MSC configuration register.
;
;	Bank A is always 2MB
;	Bank B is always 2MB
;	Bank C can be 0 or 2
;	Bank D can be 0 or 2
;	Bank E can be 0 or 2 or 8
;	Bank F can be 0 or 2 or 8
;	Bank G can be 0 or 2 or 8
;	Bank H can be 0 or 2 or 8
;_____________________________________________________________________________________________

; (CDG5) Code removed but comments kept for context

;_____________________________________________________________________________________________
; Routine:	PrattMerge																			<SM15>
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d1,d4,a5
;
; This routine stitches banks A-F together for the Pratt controller.  It then writes
; the chunk table at the top of RAM.  
;
;	Onboard RAM:
;	Bank A can be 0,2,4,or 8MB
;	Bank B can be 0,2,4,or 8MB
;	If 2MB banks, then there must be two banks, for a total of 4MB
;	If 4MB banks, then one or two banks allowed, for either 4MB or 8MB 
;	If 8MB bank,  then one or two banks allowed, for either 8MB or 16MB
;	
;	Expansion RAM:
;	Banks C,D,E,F can have 0,2,4,or 8MB.
;	All expansion banks with RAM in them must be the same size. Banks must be loaded in order.
;
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context


;_____________________________________________________________________________________________ <H7> thru next <H7>
; Routine:	djMEMCMerge																		   <SM12>begin
;
; Inputs:	d0 	- 	bases valid bits
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks 			(Banks 0 thru 7)
;			d6	-	nibble sizes for an additional 8 banks	(Banks 8 thru 15)
;			a0	-	ptr to table of base addresses
;			a1	-	ptr to universal RAMInfo table (first entry)
;			a2	-	SizeMem return address
;
; Outputs:	a5	-	points to the chunk table
;
; Destroys:	d0-d1,a5
;
;	NOTE:  If you made it here, then D6 should be zero (no errors encountered during SizeBanks).		<H8>
;			If that's true, then if D6 EXITS this code also being zero, then we should be able			<H8>
;			to abuse it during this part of the code.													<H8>
;_____________________________________________________________________________________________

; (CDG5) Code removed but comments kept for context

;_____________________________________________________________________________________________
; Routine:	expandSize
;
; Inputs:	d1.w 	- 	nibble size of this bank
;			d2		-	chunk size
;
; Outputs:	d0 		- 	.nnn...., where n = size in bytes of this bank
;
; Destroys:	d1
;
; This routine converts the nibble size in d1 to a real size (in bytes) in d0, based on a
; chunk size in d2.
;_____________________________________________________________________________________________
; (CDG5) Code removed but comments kept for context




;=============================================================================================
;_____________________________________________________________________________________________
; Routine:	writeChunkTable
;
; Inputs:	a1	-	ptr to universal RAMInfo table (first entry)
;			d1	-	size of chunk table (including 2 test longs and end of table longword)
;			d2	-	chunk size for this decoder
;			d3 	- 	total size of RAM in system
;			d5	-	nibble sizes for up to 8 banks
;			d6	-	nibble sizes for up to another 8 banks (newWriteChunkTable)
;
; Outputs:	d0 		- 	.nnn...., where n = size in bytes of this bank
;
; Destroys:	d1/d5/d6/a7
;
; Writes the chunk table at the end of RAM, based on the values passed in.  This routine
; creates a separate entry for each chunk that contains RAM.
;
; â¢â¢ New Mod <H7> â¢â¢ - If you have more than 8 banks, then you should call newWriteChunkTable
; with the first 8 banks of nibbles in D5 (as usual) and the second (up to) 8 banks of nibbles
; in D6.  The total size of the chuck table should be in D1 (1 entry for each bank plus the
; test longs at the end of the table - same as always).
;_____________________________________________________________________________________________

; (CDG5) Code removed but comments kept for context

;.............................................................................................
MergeDone
			movea.l	(a1),sp						; sp := base of RAM
			adda.l	#$8000,sp					; sp := base of RAM + 32K
			move.l	a5,-(sp)					; push ptr to chunk table on stack

;_____________________________________________________________________________________________				<SM12>begin
;
;	The comment below only applies to pre-CDG5 ROMs that did sound:
;
;	For machines with a sound buffer in high RAM (i.e., ASC-based machines), we'll move the
;	RAM chunk table below the sound buffer.  This will avoid collisions with large MMU tables.
;	We need to do this here because SizeMem gets called more than once (by diagnostics), so
;	that, for example, the warmstart flag will be valid across boots.
;
;					   BEFORE										AFTER
;
;				+-------------------+ <-- top of memory -->	+-------------------+
;				|	 RAM chunks		|						|					|
;				|-------------------|						|					|
;				|					|						|					|
;				|	BootGlobs &	+-------------------+		+-------------------+
;				|	MMU tables	|					|		|					|
;				|  will grow dow|	Sound Buffer	|		|	Sound Buffer	|
;				|		  |		|					|		|					|
;				|		  V		+-------------------+		+-------------------+
;				|					|						|	 RAM chunks		|
;				+-------------------+						|-------------------|
;															|					|
;															|	 BootGlobs &	|
;															|	 MMU tables		|
;															|  will grow down	|
;															|		 |			|
;															|		 V			|
;															|					|
;															+-------------------+
;_____________________________________________________________________________________________

			moveq	#0,d6						; Z flag set to indicate no error(s)						<15>
			jmp		(a2)


;_____________________________________________________________________________________________
;
; Routine:	SizeSoundBuffer
;
; Inputs:	D2.B-	decoder type (from Universal)
;			A2	-	return address
;			A6	-	physical address of RAM chunk table
;
; Outputs:	D0	-	size of sound buffer (zero if none)
;			A0	-	pointer to start of sound buffer
;			A1	-	pointer to end of RAM
;			A6	-	physical address of RAM chunk table
;
; Trashes:	none
;
; Function:	returns the starting address and size of a sound buffer in high RAM.
;_____________________________________________________________________________________________

SizeSoundBuffer									;															<H13>
			MOVEQ	#0,D0						; (CDG5) ROM does not do sound, so no buffer
			JMP		(A2)						; vestigial routine, return no error



	END
